<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bash]]></title>
    <url>%2F2019%2F11%2F15%2Fbash%2F</url>
    <content type="text"><![CDATA[#! 告诉系统脚本需要什么解释器来执行，即使用哪一种 Shell。如： #!/bin/sh 和 #!/bin/bash 运行Shell 脚本：./test.sh一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 变量]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth2.0]]></title>
    <url>%2F2019%2F11%2F12%2FOAuth2-0%2F</url>
    <content type="text"><![CDATA[信任问题在OAuth2.0中，简单来说有三方：用户（指属于服务方的用户）、服务方（如微信、微博等）、第三方应用 服务方不信任用户，所以需要用户提供密码或其他可信凭据服务方不信任第三方应用，所以需要第三方提供自己交给它的凭据（如微信授权的code,AppID等）用户部分信任第三方应用，所以用户愿意把自已在服务方里的某些服务交给第三方使用，但不愿意把自己在服务方的密码等交给第三方应用 角色 resource ownerAn entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. resource serverThe server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. client (代表resource owner发出请求的第三方应用平台)An application making protected resource requests on behalf of the resource owner and with its authorization. The term “client” does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices). authorization server（提供登录服务的服务器）The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.在成功验证资源所有者并获得授权后向客户端颁发访问令牌的服务器 协议流程 （Protocol Flow）1234567891011121314151617+--------+ +---------------+| |--(A)- Authorization Request -&gt;| Resource || | | Owner || |&lt;-(B)-- Authorization Grant ---| || | +---------------+| || | +---------------+| |--(C)-- Authorization Grant --&gt;| Authorization || Client | | Server || |&lt;-(D)----- Access Token -------| || | +---------------+| || | +---------------+| |--(E)----- Access Token ------&gt;| Resource || | | Server || |&lt;-(F)--- Protected Resource ---| |+--------+ +---------------+ A. Authorization Request， 第三方请求用户授权B. Authorization Grant，用户同意授权后，会从服务方获取一次性用户授权凭据(如code码)给第三方C. Authorization Grant，第三方会把授权凭据以及服务方给它的的身份凭据(如AppId)一起交给服务方的向认证服务器申请访问令牌D. Access Token，认证服务器核对授权凭据等信息，确认无误后，向第三方发送访问令牌Access Token等信息E. Access Token，通过这个Access Token向Resource Server索要数据F. Protected Resource，资源服务器使用令牌向认证服务器确认令牌的正确性，确认无误后提供资源 授权方式客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式： 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 授权码模式 用户访问客户端，后者将前者导向认证服务器 用户选择是否给予客户端授权 假设用户给予授权，认证服务器将用户导向客户端事先指定的重定向URI，同时附上一个授权码 客户端收到授权码，附上早先的重定向URI，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）等 eg: 所需参数步骤1: 客户端申请认证的URI包含以下参数： response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项。（如微信授权登录，此ID是APPID） redirect_uri：表示重定向URI，可选项 (获得code后跳转哪里) scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 123GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1HTTP/1.1 Host: server.example.com 对比网站应用微信登录：请求CODE 1https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 步骤3： 认证服务器回应客户端的URI包含以下参数： code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。 state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 123HTTP/1.1 302 FoundLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA &amp;state=xyz 步骤4：客户端向认证服务器申请令牌的HTTP请求包含以下参数： grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 code：表示上一步获得的授权码，必选项。 redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 client_id：表示客户端ID，必选项。 client_secret：客户端密钥 12345678POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb&amp;client_id=s6BhdRkqt3&amp;client_secret=dhjk33878hdfhss 对比网站应用微信登录：通过code获取access_token 1https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 步骤5：认证服务器发送的HTTP回复包含以下参数： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 123456789101112HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123; &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;, &quot;token_type&quot;:&quot;example&quot;, &quot;expires_in&quot;:3600, &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;, &quot;example_parameter&quot;:&quot;example_value&quot;&#125; 更新令牌 （refresh token）如果用户访问的时候，客户端的访问令牌access_token已经过期，则需要使用更新令牌refresh_token申请一个新的访问令牌。客户端发出更新令牌的HTTP请求，包含以下参数： grant_type：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。 refresh_token：表示早前收到的更新令牌，必选项。 scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略，表示与上一次一致。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA 简化模式简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 123456789101112131415+----------+ Client Id +---------------+| +----(A)-- &amp; Redirect URI ------&gt;| ||User-Agent| | Authorization || in |----(B)-- User authenticate ---&gt;| Server || Broswer | | || |&lt;---(C)--- Redirect URI --------| || | with Access Token +---------------+| | in Fragment| | +---------------+| |----(D)--- Redirect URI -------&gt;| Web-Server || | without Fragment | with || (F) | | Client || Access |&lt;---(E)------- Script ----------| Resource || Token | +---------------++----------+ (C) 重定向URI会在URI片断中包含访问令牌注：URI Fragment是指URI中#号之后的内容包含以下参数： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 123HTTP/1.1 302 FoundLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA &amp;state=xyz&amp;token_type=example&amp;expires_in=3600 (D) 向web服务器发送不包含URI片断的请求。user-agent在本地保存URI片断 (E) web服务器返回一个web页面（通常是嵌入了脚本的HTML网页），这个页面能够访问完整的重定向URI，它包含了由user-agent保存的URI片断，同时这个页面能够将包含在URI片断中的访问令牌（和其它参数）提取出来。 (F) user-agent在本地执行由web服务器提供的脚本，该脚本提取出访问令牌并将它传递给第三方应用平台（client） 密码模式密码模式就是将密码托管给第三方App，但是必须要保证第三方App高度可信。 1234567891011121314151617+----------+| Resource || Owner || |+----------+ | | Resource Owner (A) Password Credentials | v+---------+ +---------------+| |---(B)---- Resource Owner -------&gt;| || | Password Credentials | Authorization || Client | | Server || |&lt;--(C)---- Access Token ----------| || | (w/ Optional Refresh Token) | |+---------+ +---------------+ (A) 用户向客户端提供用户名和密码。 (B) 客户端将用户名和密码发给认证服务器，向后者请求令牌。包含以下参数： grant_type：表示授权类型，此处的值固定为”password”，必选项。 username：表示用户名，必选项。 password：表示用户的密码，必选项。 scope：表示权限范围，可选项。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w (C) 认证服务器确认无误后，向客户端提供访问令牌。 客户端模式客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 1234567+---------+ +---------------+| | | || |---(A)- Client Authentication ---&gt;| Authorization || Client | | Server || |&lt;--(B)---- Access Token ----------| || | | |+---------+ +---------------+ (A) 客户端向认证服务器进行身份认证，并要求一个访问令牌。包含以下参数： granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。 scope：表示权限范围，可选项。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials (B) 认证服务器确认无误后，向客户端提供访问令牌。 参考The OAuth 2.0 Authorization Framework 理解OAuth2.0认证与客户端授权码模式详解 理解OAuth 2.0]]></content>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudFormation]]></title>
    <url>%2F2019%2F11%2F07%2FcloudFormation%2F</url>
    <content type="text"><![CDATA[概念 AWS CloudFormation 是一项服务，可对 Amazon Web Services 资源进行建模和设置，花较少的时间管理这些资源，将更多的时间花在运行于 AWS 中的应用程序上。创建一个描述所需的所有 AWS 资源（如 Amazon EC2 实例或 Amazon RDS 数据库实例）的模板，并且 AWS CloudFormation 将负责设置和配置这些资源。无需单独创建和配置 AWS 资源， AWS CloudFormation 句柄处理工作时所依赖的内容。 模板 （template） CloudFormation 模板是 JSON 或 YAML 格式的文本文件。可以使用任何扩展名（如 .json、.yaml、.template 或 .txt）保存这些文件。CloudFormation 将这些模板作为蓝图以构建 AWS 资源。可以在单个模板中指定多种资源并将这些资源配置结合使用 堆栈（stack） 在使用 CloudFormation 时，可将相关资源作为一个称为“堆栈”的单元进行管理。可通过创建、更新和删除堆栈来管理一组资源。堆栈中的所有资源均由 CloudFormation 模板定义。假设创建了一个模板，它包括 Auto Scaling 组、Elastic Load Balancing 负载均衡器和 Amazon Relational Database Service (Amazon RDS) 数据库实例。要创建这些资源，可通过提交已创建的模板来创建堆栈，CloudFormation 将会配置所有这些资源。 更改集（change set） 如果需要更改堆栈中运行的资源，可更新堆栈。在更改资源前，您可以生成一个更改集，这是修改内容的概括。利用更改集，您可以在实施更改之前，了解更改可能会对运行的资源造成的影响。 入门资源（resource）Resources对象包含一系列资源对象，一个资源需要声明资源的属性，且必须有一个Type属性，该属性规定了要创建AWS资源的类别。该Type属性有一个特殊格式： AWS::ProductIdentifier::ResourceType For example: resource type for an Amazon S3 bucket 1234567&#123; "Resources" : &#123; "HelloBucket" : &#123; "Type" : "AWS::S3::Bucket" &#125; &#125;&#125; YAML: 123Resources: HelloBucket: Type: AWS::S3::Bucket 根据资源类型，一些属性是必需的，而其他属性是可选的。 资源属性（properties）和共同使用资源 有些资源可以有多个属性，有些属性可以有多个子属性，例如，AWS::S3::Bucket 资源具有两个属性，即 AccessControl 和 WebsiteConfiguration。WebsiteConfiguration 属性有 IndexDocument 和 ErrorDocument 两个子属性 12345678Resources: HelloBucket: Type: AWS::S3::Bucket Properties: AccessControl: PublicRead （指代了一个已存在的 ACL） WebsiteConfiguration: IndexDocument: index.html ErrorDocument: error.html Ref funtion:set properties on one resource based on the name or property of another resource, can use the Ref function to refer to an identifying property of a resource例如，创建一个 AWS::EC2::Instance 资源，该资源的 SecurityGroups 属性调用了 Ref 函数，以便能调用 AWS::EC2::SecurityGroup 资源 123456789101112131415161718Resources: Ec2Instance: Type: 'AWS::EC2::Instance' Properties: SecurityGroups: - !Ref InstanceSecurityGroup - MyExistingSecurityGroup （指代现存的 EC2 安全组） KeyName: mykey ImageId: '' InstanceSecurityGroup: Type: 'AWS::EC2::SecurityGroup' Properties: GroupDescription: Enable SSH access via port 22 SecurityGroupIngress: - IpProtocol: tcp FromPort: '22' ToPort: '22' CidrIp: 0.0.0.0/0 Ref 函数可指代那些在创建堆栈时指定的输入参数（Parameters），以下模板添加了一个 KeyName 参数对象，参数类型为 AWS::EC2::KeyPair::KeyName 12345678910111213141516171819202122Parameters: KeyName: Description: The EC2 Key Pair to allow SSH access to the instance Type: 'AWS::EC2::KeyPair::KeyName'Resources: Ec2Instance: Type: 'AWS::EC2::Instance' Properties: SecurityGroups: - !Ref InstanceSecurityGroup - MyExistingSecurityGroup KeyName: !Ref KeyName ImageId: ami-7a11e213 InstanceSecurityGroup: Type: 'AWS::EC2::SecurityGroup' Properties: GroupDescription: Enable SSH access via port 22 SecurityGroupIngress: - IpProtocol: tcp FromPort: '22' ToPort: '22' CidrIp: 0.0.0.0/0 Fn::GetAtt:返回模板中的资源的属性值，FN::GetAtt 函数有两个参数，资源的逻辑名和要检索的属性名示例代码返回 myELB 资源的 DNS 属性名称。json: 1"Fn::GetAtt" : [ "myELB" , "DNSName" ] yaml: 1!GetAtt myELB.DNSName Parameters 123456789101112131415161718Parameters: KeyName: Description: Name of an existing EC2 KeyPair to enable SSH access into the WordPress web server Type: AWS::EC2::KeyPair::KeyName WordPressUser: Default: admin NoEcho: true Description: The WordPress database admin account user name Type: String MinLength: 1 MaxLength: 16 AllowedPattern: "[a-zA-Z][a-zA-Z0-9]*" WebServerPort: Default: 8888 Description: TCP/IP port for the WordPress web server Type: Number MinValue: 1 MaxValue: 65535 参数可以有默认值，string类型可以指定MinLength、MaxLength、Default、AllowedValues 和 AllowedPattern；Number类型可以指定MinValue、MaxValue、Default 和 AllowedValues；NoEcho 属性属性让参数值不显示在控制台、命令行工具或 API 上，设置为 true将以星号的形式返回参数值 使用映射（Mappings）指定条件型值 可能会有一些根据区域而定的配置，例如 ImageId 属性写为固定的AMI ID在美国东部区域可正常使用，但用户尝试在不同区域的创建堆栈，那么将会得到一个错误的 AMI ID或得不到，因为AMI ID 对一个区域来说是唯一的，但在不同的区域同一个 AMI ID 代表内容不同，因此可使用AWS::Region 与 Mappings 对象结合，为每一个区域设置一个适当的 AMI ID 1234567891011121314151617181920212223242526Parameters: KeyName: Description: Name of an existing EC2 KeyPair to enable SSH access to the instance Type: StringMappings: RegionMap: us-east-1: AMI: ami-76f0061f us-west-1: AMI: ami-655a0a20 eu-west-1: AMI: ami-7fd4e10b ap-southeast-1: AMI: ami-72621c20 ap-northeast-1: AMI: ami-8e08a38fResources: Ec2Instance: Type: 'AWS::EC2::Instance' Properties: KeyName: !Ref KeyName ImageId: !FindInMap - RegionMap - !Ref 'AWS::Region' - AMI UserData: !Base64 '80' Fn::Join 可能存在参数值仅仅是所需值的一部分的情况，这时就需要对参数值进行拼接，以便形成所需值函数有两个参数，一个是值的分隔符，另一个是按这些值出现的顺序排列的数组例如 WebServerPort 值为 8888，目标属性将为：HTTP:8888/ 12345Target: !Join - '' - - 'HTTP:' - !Ref WebServerPort - / AWS CLI 创建堆栈: 1aws cloudformation create-stack 必须提供堆栈名称、有效模板的位置和所有输入参数,参数以空格分隔，键名称区分大小写注：如果指定了一个本地模板文件，则 CloudFormation 会将该文件上传到您的 AWS 账户中的 Amazon S3 存储桶 1aws cloudformation create-stack --stack-name myteststack --template-body file:///home/testuser/mytemplate.json 描述并列出堆栈 12aws cloudformation list-stacksaws cloudformation describe-stacks 使用 aws cloudformation list-stacks 命令可以获取已创建的任何堆栈的列表 (甚至包括已在90天内删除的堆栈)。可以使用选项按堆栈状态 (如 CREATE_COMPLETE 和 DELETE_COMPLETE) 筛选结果 1aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE aws cloudformation describe-stacks 命令提供正在运行的堆栈的相关信息。可以使用选项按堆栈名称筛选结果 1aws cloudformation describe-stacks --stack-name myteststack 列出资源 1aws cloudformation list-stack-resources --stack-name myteststack 列出资源, 该命令将列出您使用 –stack-name 参数指定的堆栈中的每个资源的汇总信息注：aws cloudformation describe-stack-resources 命令可返回90天内删除的堆栈的信息 检索模板 1aws cloudformation get-template --stack-name myteststack 模板存储为堆栈的一部分,可返回90天内删除的模板信息 验证模板 1aws cloudformation validate-template 检查您的模板文件是否存在语法错误在验证期间，首先检查模板是否是有效的 JSON。如果不是，CloudFormation 会检查模板是否是有效的 YAML。如果两种检查都失败，CloudFormation 返回模板验证错误。可以使用 --template-body 参数在本地验证模板，也可以使用 --template-url 参数进行远程验证 1aws cloudformation validate-template --template-url https://s3.amazonaws.com/cloudformation-templates-us-east-1/S3_Bucket.template 删除堆栈 1aws cloudformation delete-stack --stack-name myteststack 堆栈更新CloudFormation 会对比提交的内容与堆栈当前模板来更新资源。未更改的资源在更新过程中不中断。对于更新后的资源，CloudFormation 可能使用下列更新行为： Update with No Interruption CloudFormation 在更新资源时不中断该资源，同时不改变资源物理 ID。例如：更新AWS::CloudTrail::Trail将不会打断资源运行 Updates with Some Interruption CloudFormation 更新资源时会中断，并且保留物理 ID。例如对 AWS::EC2::Instance 资源更新特定属性，则在 CloudFormation 和 EC2 重新配置实例期间，该实例可能会中断。 ReplacementCloudFormation 在更新过程中重新创建资源，这还会生成新的物理 ID。CloudFormation 会先创建替换资源，将其他相关资源的引用变为指向替换资源，然后删除旧资源。例如，如果更新 AWS::RDS::DBInstance 资源类型的 Engine 属性，则 AWS CloudFormation 会创建新资源并将当前数据库实例资源替换为新资源。 CloudFormation 使用的更新行为取决于要更新的资源属性。 AWS Resource Types Reference 介绍了每个属性的更新行为。 使用更改集更新堆栈使用更改集可以预览更改对正在运行的资源造成什么影响，例如，无论更改是否会删除或替换任何关键资源，只有在决定执行更改集时，CloudFormation 才会对堆栈进行更改，这样可以决定是否继续执行更改，还是通过创建另一个更改集来探索其他更改。 how to use change set to update a stack: 1.通过为堆栈提交更改来创建更改集。您可以提交修改后的stack template或者修改后的输入参数值。CloudFormation 将堆栈与所提交更改进行对比，生成更改集；此时不会更改堆栈。 2.查看更改集以了解将更改哪些堆栈设置和资源。例如，可以查看CloudFormation 将添加、修改或删除哪些资源。 3.可选：如果想在决定更改之前考虑其他更改，请创建其他的更改集。创建多个更改集可了解和评估不同的更改对资源会造成什么影响，可以根据需要创建任意数量的更改集。 4.执行希望应用到堆栈的更改集。CloudFormation 使用这些更改更新您的堆栈。 注：执行更改后，CloudFormation 将删除与堆栈关联的所有更改集 创建更改集 1aws cloudformation create-change-set 指定新参数值和/或修改后的模板。以下命令为 SampleChangeSet 堆栈创建名为 SampleStack 的更改集。更改集使用当前堆栈的模板，但 Purpose 参数具有不同值： 12aws cloudformation create-change-set --stack-name arn:aws:cloudformation:us-east-1:123456789012:stack/SampleStack/1a2345b6-0000-00a0-a123-00abc0abc000--change-set-name SampleChangeSet --use-previous-template --parameters ParameterKey="InstanceType",UsePreviousValue=true ParameterKey="KeyPairName",UsePreviousValue=true ParameterKey="Purpose",ParameterValue="production" 查看更改集 12345aws cloudformation list-change-sets --stack-name arn:aws:cloudformation:us-east-1:123456789012:stack/SampleStack/1a2345b6-0000-00a0-a123-00abc0abc000(stack id)aws cloudformation describe-change-set --change-set-name arn:aws:cloudformation:us-east-1:123456789012:changeSet/SampleChangeSet/1a2345b6-0000-00a0-a123-00abc0abc000(change set id) 执行更改集 (change set id) 1aws cloudformation execute-change-set --change-set-name arn:aws:cloudformation:us-east-1:123456789012:changeSet/SampleChangeSet/1a2345b6-0000-00a0-a123-00abc0abc000 删除更改集 (change set id) 1aws cloudformation delete-change-set --change-set-name arn:aws:cloudformation:us-east-1:123456789012:changeSet/SampleChangeSet/1a2345b6-0000-00a0-a123-00abc0abc000 直接更新堆栈 1aws cloudformation update-stack --stack-name mystack --template-url https://s3.amazonaws.com/sample/updated.template 运行当创建堆栈时，CloudFormation 对 AWS 基础服务调用配置资源。CloudFormation 只能执行有执行权限的操作。例如，要使用 CloudFormation 创建 EC2 实例，需要具有创建实例的权限。可以使用 Identity and Access Management (IAM) 管理权限。 CloudFormation 进行的调用全部由模板声明 更改集更新堆栈 更新堆栈的资源，不需要创建新堆栈和删除旧堆栈 注：更改集并不指示堆栈更新是否会成功。例如，更改集不检查是否将超出账户限制、是否将更新不支持更新的资源或者权限不足而无法修改资源，这些都将导致堆栈更新失败。 删除堆栈 在删除堆栈时，可指定要删除的堆栈，CloudFormation 将删除该堆栈及其包含的所有资源若要删除一个堆栈但保留该堆栈中的一些资源，可使用删除策略来保留那些资源 设置 使用 IAM 控制访问 可以创建 IAM 用户以控制谁有权访问 AWS 账户中的哪些资源。可以将 IAM 与 CloudFormation 结合以控制用户使用 CloudFormation 执行操作，例如，是否可以查看堆栈模板、创建堆栈或删除堆栈。 When you create a group or an IAM user in your AWS account, you can associate an IAM policy with that group or user, which specifies the permissions that you want to grant. 12345678910111213&#123; "Version":"2012-10-17", "Statement":[&#123; "Effect":"Allow", "Action":[ "cloudformation:DescribeStacks", "cloudformation:DescribeStackEvents", "cloudformation:DescribeStackResource", "cloudformation:DescribeStackResources" ], "Resource":"*" &#125;]&#125; 注：If you don’t specify a stack name or ID in your statement, you must also grant the permission to use all resources for the action using the * wildcard for the Resource element. CloudFormation 资源 CloudFormation 支持资源级权限，因此可以指定针对特定堆栈的操作。如拒绝MyProductionStack 的删除和更新堆栈操作的策略示例 1234567891011&#123; "Version":"2012-10-17", "Statement":[&#123; "Effect":"Deny", "Action":[ "cloudformation:DeleteStack", "cloudformation:UpdateStack" ], "Resource":"arn:aws:cloudformation:us-east-1:123456789012:stack/MyProductionStack/*" &#125;]&#125; CloudFormation 条件 可以指定控制策略何时生效 AWS::*指定所有 AWS 资源。 AWS::service_name::*指定用于特定 AWS 服务的所有资源。 AWS::service_name::resource_type指定特定的 AWS 资源类型，如 AWS::EC2::Instance (所有 EC2 实例)。 Custom::*指定所有自定义资源。 Custom::resource_type指定特定的自定义资源类型 (在模板中定义)。 cloudformation:RoleARNUse this condition to control which service role IAM users can use when they work with stacks or change sets. cloudformation:StackPolicyUrl在创建或更新堆栈操作期间，使用此条件控制 IAM 用户可将哪些堆栈policy关联到堆栈 。 cloudformation:TemplateUrl与策略关联的 S3 模板 URL。使用此条件控制 IAM 用户在创建或更新堆栈时可以使用的模板。 示例中用户只能使用 https://s3.amazonaws.com/testbucket/test.template 模板 URL 创建或更新堆栈。 1234567891011121314151617&#123; "Version":"2012-10-17", "Statement":[ &#123; "Effect" : "Allow", "Action" : [ "cloudformation:CreateStack", "cloudformation:UpdateStack" ], "Resource" : "*", "Condition" : &#123; "ForAllValues:StringEquals" : &#123; "cloudformation:TemplateUrl" : [ "https://s3.amazonaws.com/testbucket/test.template" ] &#125; &#125; &#125; ]&#125;]]></content>
      <tags>
        <tag>AWS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F10%2F10%2Flinux%2F</url>
    <content type="text"><![CDATA[man 命令名 #查看命令的详细说明命令名 -help #查看命令的常用选项 1 下载与安装 下载： wget url #下载文件 （wget 命令常用于下载） curl www.baidu.com #请求指定网址并显示 （curl 命令可用于各种请求方式，常用于上传与请求）安装：解压缩 （如：tar -xzvf soft.tar.gz），进入解压后的文件夹 ./configure（生成makefile文件） make make install2 文件命令 创建文件：touch 文件名 删除文件：rm -rf 文件名 #r代表递归，f代表强制删除 查看文件： 建立软连接：ln -s 源文件 目标文件 #文件名都必须写绝对路径 #删除了源文件，那么目标文件就会被标识为红色，但仍指向源文件；重新新建源文件，目标文件依然可用比较文件差异：diff 选项 文件一 文件二 3 目录操作 4 文件和目录操作 更改用户：sudo chown -R $USER /usr/local/lib/node_modules 5 权限管理 6 压缩解压 7 查找搜索 8 SSH ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是IP/域名，或者是别名 port 是SSH Server监听的端口，如果不指定，就为默认值22 (使用exit退出当前用户的登录)设置ssh密钥：ssh-keygen 上传公钥到服务器： ssh-copy-id -p port user@remote（ssh-copy-id -p 22 deepin2@192.168.56.132） 让远程服务器记住密钥，之后免密登陆9 快捷键]]></content>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常见命令]]></title>
    <url>%2F2019%2F10%2F10%2Fgit%2F</url>
    <content type="text"><![CDATA[git基本使用流程： git add [files] git commit git pull --rebase ( if conflicts happen, resolve merge conflicts ) git rebase --continue git push在任何时候，都可以用git rebase –abort参数来终止rebase的行动，并且分支会回到rebase开始前的状态。 git pull = git fetch + git merge git pull --rebase = git fetch + git rebase1 切换分支： git checkout [branch name] git checkout -- a.txt # 丢弃某个文件修改 git checkout -- . # 丢弃全部创建分支 git branch [branch name] 切换并生成分支 git checkout -b [branch name] 2 合并分支：切换到主分支，使用 git merge / git rebase 假设目前存在两个分支master、bugfix 使用git merge，合并两个修改会生成一个提交，master分支的HEAD会移动到该提交上。 git rebase bugfix分支到master分支, bugfix分支的历史记录会添加在master分支的后面。 3 添加远程库：git remote add origin [repo name] git push -u origin master = git push origin master ; git branch --set-upstream master origin/master 使用-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来–set-upstream：sets the default remote branch for the current local branch. 4 版本回退：假设C 和 D 是错误提交 git reset: Use this to return the entire working tree to the last committed state. This will discard commits in a private branch or throw away uncommitted changes! Changes which commit a branch HEAD is currently pointing at. It alters the existing commit history. 如果使用：git reset –hard a0fvf8；失去C和D的提交信息 git reset --soft xxx：只回退commit，如果你想再次提交直接git commit即可 git reset --hard xxx：彻底回退版本，连本地文件都会被回退到上个版本的内容git revert : Rollback changes you have committed. Creates a new commit from a specified commit by inverting it. Hence, adds a new commit history to the project, but it does not modify the existing one. 先 revert D，再 revert Cgit revert 5lk4er; git revert 76sdeb生成两个新有提交：D’ 和 C’,错误的提交 C 和 D 依然保留 revert多个提交 git revert OLDER_COMMIT^..NEWER_COMMIT （git revert B^..D -&gt; revert B,C,D） 如果不想三个revert生成三个新的commit，而是用一个commit完成，可以：git revert -n OLDER_COMMIT^..NEWER_COMMITgit commit -m “revert OLDER_COMMIT to NEWER_COMMIT” eg: 错误提交位于中间,直接使用 git reset 命令将 HEAD 指针重置到 A 提交显然是不行的，因为 C 提交是正确的，需要保留的。 推荐做法：先把 C 提交 及 B 提交全部回退，再使用 cherry-pick 命令将 C 提交重新再生成一个新的提交 C’ 5 cherry-pick： 只将C2合并到master，丢弃C3的修改 用git log查看C2 commit的id git checkout 到master分支下 git cherry-pick 如果出现冲突， 先解决冲突 git add 将解决了冲突的文件添加到暂存区 git cherry-pick –continue 6 git reflog： 可以查看所有分支的所有操作记录]]></content>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 基本概念与命令]]></title>
    <url>%2F2019%2F10%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[docker / docker-compose 相关概念及常用命令 Docker - 基本概念Docker是一种容器，操作系统级别的轻量级虚拟化，可以把环境一起打包扔给各服务器，随时随地都能运行。（保证运行环境一致） Docker镜像（image）：相当于root文件系统，内核启动后为其提供用户空间支持。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 Docker容器（container）：实质是进程，镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，image是container的静态定义（可类比 hello_world.py文件 和 对应的hello_world进程），容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 Docker Register：镜像构建完成后，如果需要在其它服务器上使用，那么就需要一个集中的存储、分发镜像的服务一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像 - 常用命令1. 镜像 &lt;1&gt; 获取镜像：docker pull [选项] [Docker Registry 地址 [:端口号] /] 仓库名 [:标签] Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 仓库名： &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。&lt;2&gt;列出镜像：docker image ls 查看中间层镜像：docker image ls -a 列出部分镜像： 根据仓库名列出镜像：docker image ls ubuntu 指定仓库名和标签：docker image ls ubuntu:18.04 过滤器参数（--filter）：docker image ls -f since=mongo:3.2 （mongo:3.2之后的镜像） 以特定格式显示（-q/--format）：docker image ls --format &quot;{{.ID}} : {{.Repository}}&quot;&lt;3&gt;删除虚悬镜像：docker image prune &lt;4&gt;删除本地镜像：docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …] 配合 ls使用：docker image rm $(docker image ls -q redis) （删除所有仓库名为redis的镜像） docker image rm $(docker image ls -q -f before=mongo:3.2)。（删除所有在mongo:3.2之前的镜像）&lt;5&gt;运行容器时修改了文件，保存成最终镜像：docker commit [选项]&lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]] （慎用，黑箱镜像） eg：docker commit --author &quot;Tao Wang &lt;[twang2218@gmail.com](mailto:twang2218@gmail.com)&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2&lt;6&gt;定制镜像：Dockerfile 一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 From指定基础镜像，Run 执行命令 构建镜像：docker build [选项] &lt;上下文路径/URL/-&gt;2. 容器 &lt;1&gt;新建并启动：docker run &lt;2&gt;启动已终止容器：docker container start [container ID or NAMES] &lt;3&gt;后台运行(-d): docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done”&lt;4&gt;查看容器信息：docker container ls &lt;5&gt; 获取容器的输出信息：docker container logs [container ID or NAMES] &lt;6&gt;终止容器：docker container stop [container ID or NAMES] &lt;7&gt;重启运行中的容器：docker container restart [container ID or NAMES] &lt;8&gt;进入容器：docker attach [container ID or NAMES] (从 stdin 中 exit，会导致容器停止) docker exec -it [container ID or NAMES] bash (从 stdin 中 exit，不会导致容器停止，推荐) &gt; -I: interactive, keep stdin -iopen &gt; -t: 分配伪终端&lt;9&gt;导出容器：docker export [container ID] &gt; ubuntu.tar &lt;10&gt;导入容器：cat ubuntu.tar | docker import - test/ubuntu:v1.0 &lt;11&gt;删除容器：docker container rm [container ID or NAMES] （运行中的容器可使用-f参数） &lt;12&gt;清理所有处于终止状态的容器：docker container prune 3. 仓库 &lt;1&gt;查找官方仓库中的镜像：docker search &lt;2&gt;推送镜像到 Docker Hub：docker push 4. 数据管理 &lt;1&gt;数据卷 创建：docker volume create my-vol 查看：docker volume ls 启动一个挂载数据卷的容器（--mount）：docker run -d -P \ --name web \ --mount source=my-vol,target=/webapp \ training/webapp \ python [app.py](http://app.py/) （创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。） 查看数据卷的具体信息：docker inspect web 删除数据卷：docker volume rm my-vol5. 使用网络 &lt;1&gt;外部访问容器（-P/-p）：docker run -d -P training/webapp python app.py (使用-P标记时，Docker 会随机映射一个49000~49900的端口到内部容器开放的网络端口) docker run -d -p 5000:5000 training/webapp python [app.py](http://app.py/) (本地的5000 端口映射到容器的5000 端口) 127.0.0.1:5000:5000 指定地址到指定端口 / 127.0.0.1::5000 指定地址的任意端口 / 127.0.0.1:5000:5000/udp 指定 udp 端口 -p可以多次使用来绑定多个端口&lt;2&gt;查看映射端口配置：docker port nostalgic_morse 5000 &lt;3&gt; 新建网络：docker network create -d bridge my-net &gt; -d 参数指定 Docker 网络类型，有 bridge、overlay&lt;4&gt;连接容器： docker run -it --rm --name busybox1 --network my-net busybox sh （运行一个容器并连接到新建的 my-net 网络） docker run -it --rm --name busybox2 --network my-net busybox sh （再运行一个容器并加入到 my-net 网络） &gt; busybox1 与 busybox2 可相互ping通Example : 1.安装Ubuntu：docker pull ubuntu 2.run container : docker run -tid –name ubuntu -p 23:22 ubuntu：将新建的docker命名为ubuntu并映射到23端口 3.查看23号端口是否开启：netstat -apnl | grep 23（linux） / netstat -AaLlnW ｜grep 23（mac）/ lsof -i:23 (mac) 4.进入container：docker exec -ti ubuntu /bin/bash 5.修改root密码：passwd 6.更新vim：apt install -y vim （也许需要apt update） 7.安装openssh-server： apt install -y openssh-server 8.修改配置，可使用root登录：vim /etc/ssh/sshd_config ，添加PermitRootLogin yes ；添加UsePAM no 9.启动ssh：service ssh start 10.重新进入docker container：ssh root@ip -p 23 Docker-compose - 基本概念定义和运行多个 Docker 容器的应用，允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目 &gt; 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 &gt; 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。docker-compose [-f=…] [options] [COMMAND] [ARGS…] VM 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。]]></content>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有知识的荒原]]></title>
    <url>%2F2019%2F04%2F12%2Fwelcome%2F</url>
    <content type="text"><![CDATA[真的 没有意思！]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
