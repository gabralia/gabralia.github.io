<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git常见命令]]></title>
    <url>%2F2019%2F10%2F10%2Fgit%2F</url>
    <content type="text"><![CDATA[git add [files] git commit git pull –rebase ( if conflicts happen, resolve merge conflicts ) git rebase –continue git push 在任何时候，都可以用git rebase –abort参数来终止rebase的行动，并且分支会回到rebase开始前的状态。 git pull = git fetch + git merge git pull –rebase = git fetch + git rebase 1 切换分支： git checkout [branch name] git checkout – a.txt # 丢弃某个文件修改 git checkout -- . # 丢弃全部 创建分支 git branch [branch name] 切换并生成分支 git checkout -b [branch name] 2 合并分支：切换到主分支，使用 git merge / git rebase 假设目前存在两个分支master、bugfix 使用git merge，合并两个修改会生成一个提交，master分支的HEAD会移动到该提交上。 git rebase bugfix分支到master分支, bugfix分支的历史记录会添加在master分支的后面。 3 添加远程库：git remote add origin [repo name] git push -u origin master = git push origin master ; git branch --set-upstream master origin/master 使用-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 –set-upstream：sets the default remote branch for the current local branch. 4 版本回退：假设C 和 D 是错误提交 git reset: Use this to return the entire working tree to the last committed state. This will discard commits in a private branch or throw away uncommitted changes! Changes which commit a branch HEAD is currently pointing at. It alters the existing commit history. git reset –hard a0fvf8；git push -f 失去C和D的提交信息 git reset –soft xxx：只回退commit，如果你想再次提交直接git commit即可 git reset –hard xxx：彻底回退版本，连本地文件都会被回退到上个版本的内容 git revert : Rollback changes you have committed. Creates a new commit from a specified commit by inverting it. Hence, adds a new commit history to the project, but it does not modify the existing one. 先 revert D，再 revert C git revert 5lk4er; git revert 76sdeb 生成两个新有提交：D’ 和 C’,错误的提交 C 和 D 依然保留 revert多个提交： git revert OLDER_COMMIT^..NEWER_COMMIT （git revert B^..D -&gt; revert B,C,D） 如果不想三个revert生成三个新的commit，而是用一个commit完成，可以： git revert -n OLDER_COMMIT^..NEWER_COMMIT git commit -m “revert OLDER_COMMIT to NEWER_COMMIT” eg: 错误提交位于中间,直接使用 git reset 命令将 HEAD 指针重置到 A 提交显然是不行的，因为 C 提交是正确的，需要保留的。先把 C 提交 及 B 提交全部回退，再使用 cherry-pick 命令将 C 提交重新再生成一个新的提交 C’’ 5 cherry-pick： | C3 | | C1 C2 | | test | / | / master 只将C2合并到master，丢弃C3的修改 用git log查看C2 commit的id git checkout 到master分支下 git cherry-pick &lt;C2_id&gt; 如果出现冲突， 先解决冲突 git add 将解决了冲突的文件添加到暂存区 git cherry-pick –continue]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 基本概念与命令]]></title>
    <url>%2F2019%2F10%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[docker / docker-compose 相关概念及常用命令 Docker - 基本概念Docker是一种容器，操作系统级别的轻量级虚拟化，可以把环境一起打包扔给各服务器，随时随地都能运行。（保证运行环境一致） Docker镜像（image）：相当于root文件系统，内核启动后为其提供用户空间支持。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 Docker容器（container）：实质是进程，镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，image是container的静态定义（可类比 hello_world.py文件 和 对应的hello_world进程），容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 Docker Register：镜像构建完成后，如果需要在其它服务器上使用，那么就需要一个集中的存储、分发镜像的服务一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像 - 常用命令1. 镜像 获取镜像：docker pull [选项] [Docker Registry 地址 [:端口号] /] 仓库名 [:标签] &gt; Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 &gt; 仓库名： &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 列出镜像：docker image ls 查看中间层镜像：docker image ls -a 列出部分镜像： 根据仓库名列出镜像：docker image ls ubuntu 指定仓库名和标签：docker image ls ubuntu:18.04 过滤器参数（--filter）：docker image ls -f since=mongo:3.2 （mongo:3.2之后的镜像） 以特定格式显示（-q/--format）：docker image ls --format &quot;{{.ID}} : {{.Repository}}&quot; 删除虚悬镜像：docker image prune 删除本地镜像：docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …] 配合 ls使用：docker image rm $(docker image ls -q redis) （删除所有仓库名为redis的镜像） docker image rm $(docker image ls -q -f before=mongo:3.2)。（删除所有在mongo:3.2之前的镜像） 运行容器时修改了文件，保存成最终镜像：docker commit [选项]&lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]] （慎用，黑箱镜像） eg：docker commit --author &quot;Tao Wang &lt;[twang2218@gmail.com](mailto:twang2218@gmail.com)&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2 定制镜像：Dockerfile 一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 From指定基础镜像，Run 执行命令 构建镜像：docker build [选项] &lt;上下文路径/URL/-&gt; 2. 容器 新建并启动：docker run 启动已终止容器：docker container start [container ID or NAMES] 后台运行(-d):docker run -d ubuntu:18.04 /bin/sh -c “while true; do echo hello world; sleep 1; done” 查看容器信息：docker container ls 获取容器的输出信息：docker container logs [container ID or NAMES] 终止容器：docker container stop [container ID or NAMES] 重启运行中的容器：docker container restart [container ID or NAMES] 进入容器：docker attach [container ID or NAMES] (从 stdin 中 exit，会导致容器停止) docker exec -it [container ID or NAMES] bash (从 stdin 中 exit，不会导致容器停止，推荐) &gt; -I: interactive, keep stdin -iopen &gt; -t: 分配伪终端 导出容器：docker export [container ID] &gt; ubuntu.tar 导入容器：cat ubuntu.tar | docker import - test/ubuntu:v1.0 删除容器：docker container rm [container ID or NAMES] （运行中的容器可使用-f参数） 清理所有处于终止状态的容器：docker container prune 3. 仓库 查找官方仓库中的镜像：docker search 推送镜像到 Docker Hub：docker push 4. 数据管理 数据卷 创建：docker volume create my-vol 查看：docker volume ls 启动一个挂载数据卷的容器（--mount）：docker run -d -P \ --name web \ --mount source=my-vol,target=/webapp \ training/webapp \ python [app.py](http://app.py/) （创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。） 查看数据卷的具体信息：docker inspect web 删除数据卷：docker volume rm my-vol 5. 使用网络 外部访问容器（-P/-p）：docker run -d -P training/webapp python app.py (使用-P标记时，Docker 会随机映射一个49000~49900的端口到内部容器开放的网络端口) docker run -d -p 5000:5000 training/webapp python [app.py](http://app.py/) (本地的5000 端口映射到容器的5000 端口) 127.0.0.1:5000:5000 指定地址到指定端口 / 127.0.0.1::5000 指定地址的任意端口 / 127.0.0.1:5000:5000/udp 指定 udp 端口 -p可以多次使用来绑定多个端口 查看映射端口配置：docker port nostalgic_morse 5000 新建网络：docker network create -d bridge my-net &gt; -d 参数指定 Docker 网络类型，有 bridge overlay 连接容器： docker run -it --rm --name busybox1 --network my-net busybox sh （运行一个容器并连接到新建的 my-net 网络） docker run -it --rm --name busybox2 --network my-net busybox sh （再运行一个容器并加入到 my-net 网络） &gt; busybox1 与 busybox2 可相互ping通 Example : 1.安装Ubuntu：docker pull ubuntu 2.run container : docker run -tid –name ubuntu -p 23:22 ubuntu：将新建的docker命名为ubuntu并映射到23端口 3.查看23号端口是否开启：netstat -apnl | grep 23（linux） / netstat -AaLlnW ｜grep 23（mac）/ lsof -i:23 (mac) 4.进入container：docker exec -ti ubuntu /bin/bash 5.修改root密码：passwd 6.更新vim：apt install -y vim （也许需要apt update） 7.安装openssh-server： apt install -y openssh-server 8.修改配置，可使用root登录：vim /etc/ssh/sshd_config ，添加PermitRootLogin yes ；添加UsePAM no 9.启动ssh：service ssh start 10.重新进入docker container：ssh root@ip -p 23 Docker-compose - 基本概念定义和运行多个 Docker 容器的应用，允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目 &gt; 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 &gt; 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 docker-compose [-f=…] [options] [COMMAND] [ARGS…] VM 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有知识的荒原]]></title>
    <url>%2F2019%2F04%2F12%2Fwelcome%2F</url>
    <content type="text"><![CDATA[真的没有意思！]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
