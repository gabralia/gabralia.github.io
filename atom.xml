<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜻蜓队长前来觐见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-11-15T17:41:06.971Z</updated>
  <id>/</id>
  
  <author>
    <name>Jinnew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bash</title>
    <link href="/2019/11/15/bash/"/>
    <id>/2019/11/15/bash/</id>
    <published>2019-11-15T09:58:21.000Z</published>
    <updated>2019-11-15T17:41:06.971Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><code>#! 告诉系统脚本需要什么解释器来执行，即使用哪一种 Shell。</code><br>如： #!/bin/sh 和 #!/bin/bash</p></li><li><p>运行Shell 脚本：./test.sh<br>一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p></li></ul><a id="more"></a><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="定义变量："><a href="#定义变量：" class="headerlink" title="定义变量："></a>定义变量：</h5><p>your_name=”runoob.com”</p><ul><li>变量名和等号之间不能有空格。</li><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）</li></ul><p>除了显式地直接赋值，还可以用语句给变量赋值，如将 /etc 下目录的文件名循环出来：<br>for file in <code>ls /etc</code><br>for file in $(ls /etc)</p><h5 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h5><blockquote><p>echo $your_name<br>echo ${your_name}</p></blockquote><p>使用一个定义过的变量，只要在变量名前面加美元符号即可</p><h5 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h5><blockquote><p>myUrl=”<a href="http://www.google.com&quot;" target="_blank" rel="noopener">http://www.google.com&quot;</a><br>readonly myUrl</p></blockquote><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><blockquote><p>unset variable_name</p></blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote><p>str=’this is a string’</p></blockquote><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</p><blockquote><p>your_name=’runoob’</p><p>str=”Hello, I know you are &quot;$your_name&quot;! \n”</p></blockquote><p>双引号里可以有变量<br>双引号里可以出现转义字符</p><blockquote><p>your_name=”runoob”</p><p>greeting=”hello, “$your_name” !”</p><p>greeting_1=”hello, ${your_name} !”</p><p>greeting_2=’hello, ‘$your_name’ !’</p></blockquote><h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><blockquote><p>string=”abcd”</p><p>echo ${<code>#string</code>} #输出 4</p></blockquote><h5 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h5><blockquote><p>string=”runoob is a great site”</p><p>echo ${string:1:4} # 输出 unoo</p></blockquote><h5 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h5><p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</p><blockquote><p>string=”runoob is a great site”</p><p>echo `expr index “$string” io`  # 输出 4</p></blockquote><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>定义数组： 数组名=(值1 值2 … 值n)</p><blockquote><p>array_name=(value0 value1 value2 value3)</p></blockquote><p>取得数组元素的个数</p><blockquote><p>length=${<code>#array_name[@]</code>}</p><p>length=${<code>#array_name[*]</code>}</p></blockquote><p>取得数组单个元素的长度</p><blockquote><p>lengthn=${<code>#array_name[n]</code>}</p></blockquote><p>多行注释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">content...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">content...</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p><img src="/2019/11/15/bash/m-2019-11-13-11-46-43.png" alt></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><blockquote><p>val=<code>expr 2 + 2</code><br>echo “两数之和为 : $val”</p></blockquote><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p><img src="/2019/11/15/bash/m-2019-11-13-11-53-03.png" alt></p><h5 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h5><p><img src="/2019/11/15/bash/m-2019-11-13-11-56-01.png" alt></p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p><img src="/2019/11/15/bash/m-2019-11-13-11-58-08.png" alt></p><h5 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h5><p><img src="/2019/11/15/bash/m-2019-11-14-12-00-11.png" alt></p><h5 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h5><p><img src="/2019/11/15/bash/m-2019-11-14-12-01-56.png" alt></p><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><ul><li>显示变量<br>#!/bin/sh<br>read name<br>echo “$name It is a test”</li></ul><blockquote><p>sh test.sh<br>OK                    #标准输入<br>OK It is a test        #输出</p></blockquote><ul><li>显示换行<br>echo -e “OK! \n” # -e 开启转义<br>echo “It is a test”</li></ul><blockquote><p>OK! </p><p>It is a test</p></blockquote><ul><li>显示不换行<br>#!/bin/sh<br>echo -e “OK! \c” # -e 开启转义 \c 不换行<br>echo “It is a test”</li></ul><blockquote><p>OK! It is a test</p></blockquote><ul><li>显示结果定向至文件<br>echo “It is a test” &gt; myfile</li></ul><h4 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h4><p>Shell中 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><h5 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h5><p><img src="/2019/11/15/bash/m-2019-11-14-10-53-23.png" alt></p><p>num1=100<br>num2=100<br>if test $[num1] -eq $[num2]</p><p>代码中的 [] 执行基本的算数运算，如：<br>result=$[a+b]</p><h5 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h5><p><img src="/2019/11/15/bash/m-2019-11-14-10-55-04.png" alt></p><blockquote><p>num1=”ru1noob”<br>num2=”runoob”<br>if test $num1 = $num2</p></blockquote><h5 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h5><p><img src="/2019/11/15/bash/m-2019-11-14-10-56-44.png" alt></p><blockquote><p>if test -e ./bash</p></blockquote><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><ul><li>if else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if else-if else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h5 id="until"><a href="#until" class="headerlink" title="until"></a>until</h5><p>until 循环执行一系列命令直至条件为 true 时停止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h5 id="case"><a href="#case" class="headerlink" title="case"></a>case</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span>    <span class="comment">#倒过来的case</span></span><br></pre></td></tr></table></figure><p>取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><ul><li>break</li><li>contine</li></ul><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><p><img src="/2019/11/15/bash/m-2019-11-14-11-15-50.png" alt></p><p>统计 users 文件的行数,执行以下命令：</p><blockquote><p>wc -l users  </p></blockquote><p>也可以将输入重定向到 users 文件：</p><blockquote><p> wc -l &lt; users</p></blockquote><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名: 2 users；第二个不会, 仅输出：2，因为它仅仅知道从标准输入读取内容。</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><blockquote><p>command 2 &gt; file</p></blockquote><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><blockquote><p>command 2 &gt;&gt; file</p></blockquote><ul><li>表示标准错误文件(stderr)。</li></ul><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><blockquote><p>command &gt; file 2&gt;&amp;1</p></blockquote><p>或者</p><blockquote><p>command &gt;&gt; file 2&gt;&amp;1</p></blockquote><ul><li>/dev/null 文件</li></ul><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null,写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到.</p><blockquote><p>command &gt; /dev/null</p></blockquote><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><blockquote><p>command &gt; /dev/null 2&gt;&amp;1</p></blockquote><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>Shell 也可以包含外部脚本</p><blockquote><p>. filename   #注意点号(.)和文件名中间有一空格</p></blockquote><p>或</p><blockquote><p>source filename</p></blockquote><h4 id="Bash-scripting-cheatsheet"><a href="#Bash-scripting-cheatsheet" class="headerlink" title="Bash scripting cheatsheet"></a>Bash scripting cheatsheet</h4><p><a href="https://devhints.io/bash" target="_blank" rel="noopener">Bash scripting cheatsheet</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;#! 告诉系统脚本需要什么解释器来执行，即使用哪一种 Shell。&lt;/code&gt;&lt;br&gt;如： #!/bin/sh 和 #!/bin/bash&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行Shell 脚本：./test.sh&lt;br&gt;一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0</title>
    <link href="/2019/11/12/OAuth2-0/"/>
    <id>/2019/11/12/OAuth2-0/</id>
    <published>2019-11-11T16:39:07.000Z</published>
    <updated>2019-11-11T16:50:05.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h3><p>在OAuth2.0中，简单来说有三方：用户（指属于服务方的用户）、服务方（如微信、微博等）、第三方应用</p><a id="more"></a><p>服务方不信任用户，所以需要用户提供密码或其他可信凭据<br>服务方不信任第三方应用，所以需要第三方提供自己交给它的凭据（如微信授权的code,AppID等）<br>用户部分信任第三方应用，所以用户愿意把自已在服务方里的某些服务交给第三方使用，但不愿意把自己在服务方的密码等交给第三方应用</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><p>resource owner<br>An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user.</p></li><li><p>resource server<br>The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.</p></li><li><p>client (代表resource owner发出请求的第三方应用平台)<br>An application making protected resource requests on behalf of the resource owner and with its authorization.  The term “client” does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).</p></li><li><p>authorization server（提供登录服务的服务器）<br>The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.<br>在成功验证资源所有者并获得授权后向客户端颁发访问令牌的服务器</p></li></ul><h3 id="协议流程-（Protocol-Flow）"><a href="#协议流程-（Protocol-Flow）" class="headerlink" title="协议流程 （Protocol Flow）"></a>协议流程 （Protocol Flow）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br></pre></td></tr></table></figure><p>A. <code>Authorization Request</code>， 第三方请求用户授权<br>B. <code>Authorization Grant</code>，用户同意授权后，会从服务方获取一次性用户授权凭据(如code码)给第三方<br>C. <code>Authorization Grant</code>，第三方会把授权凭据以及服务方给它的的身份凭据(如AppId)一起交给服务方的向认证服务器申请访问令牌<br>D. <code>Access Token</code>，认证服务器核对授权凭据等信息，确认无误后，向第三方发送访问令牌Access Token等信息<br>E. <code>Access Token</code>，通过这个Access Token向Resource Server索要数据<br>F. <code>Protected Resource</code>，资源服务器使用令牌向认证服务器确认令牌的正确性，确认无误后提供资源</p><h3 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h3><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式：</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p><img src="/2019/11/12/OAuth2-0/A07FDDD8-8B95-474B-9C79-6315F52636F1.png" alt></p><ol><li>用户访问客户端，后者将前者导向认证服务器</li><li>用户选择是否给予客户端授权</li><li>假设用户给予授权，认证服务器将用户导向客户端事先指定的重定向URI，同时附上一个授权码</li><li>客户端收到授权码，附上早先的重定向URI，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见</li><li>认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）等</li></ol><p>eg:<br><img src="/2019/11/12/OAuth2-0/11573486684_.pic.jpg" alt></p><h5 id="所需参数"><a href="#所需参数" class="headerlink" title="所需参数"></a>所需参数</h5><p>步骤1: 客户端申请认证的URI<br>包含以下参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项。（如微信授权登录，此ID是APPID）</li><li>redirect_uri：表示重定向URI，可选项 (获得code后跳转哪里)</li><li>scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">HTTP/1.1 Host: server.example.com</span><br></pre></td></tr></table></figure><p>对比网站应用微信登录：请求CODE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</span><br></pre></td></tr></table></figure><p>步骤3： 认证服务器回应客户端的URI<br>包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>步骤4：客户端向认证服务器申请令牌的HTTP请求<br>包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li><li>client_secret：客户端密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br><span class="line">&amp;client_id=s6BhdRkqt3&amp;client_secret=dhjk33878hdfhss</span><br></pre></td></tr></table></figure><p>对比网站应用微信登录：通过code获取access_token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure><p>步骤5：认证服务器发送的HTTP回复<br>包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更新令牌-（refresh-token）"><a href="#更新令牌-（refresh-token）" class="headerlink" title="更新令牌 （refresh token）"></a>更新令牌 （refresh token）</h5><p>如果用户访问的时候，客户端的访问令牌access_token已经过期，则需要使用更新令牌refresh_token申请一个新的访问令牌。<br>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。</li><li>refresh_token：表示早前收到的更新令牌，必选项。</li><li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略，表示与上一次一致。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure><h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+----------+            Client Id           +---------------+</span><br><span class="line">|          +----(A)-- &amp; Redirect URI ------&gt;|               |</span><br><span class="line">|User-Agent|                                | Authorization |</span><br><span class="line">|    in    |----(B)-- User authenticate ---&gt;|     Server    |</span><br><span class="line">|  Broswer |                                |               |</span><br><span class="line">|          |&lt;---(C)--- Redirect URI --------|               |</span><br><span class="line">|          |         with Access Token      +---------------+</span><br><span class="line">|          |            in Fragment</span><br><span class="line">|          |                                +---------------+</span><br><span class="line">|          |----(D)--- Redirect URI -------&gt;|   Web-Server  |</span><br><span class="line">|          |          without Fragment      |     with      |</span><br><span class="line">|   (F)    |                                |     Client    |</span><br><span class="line">|  Access  |&lt;---(E)------- Script ----------|     Resource  |</span><br><span class="line">|   Token  |                                +---------------+</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><p>(C) 重定向URI会在URI片断中包含访问令牌<br>注：URI Fragment是指URI中#号之后的内容<br>包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">               &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure><p>(D) 向web服务器发送不包含URI片断的请求。user-agent在本地保存URI片断</p><p>(E) web服务器返回一个web页面（通常是嵌入了脚本的HTML网页），这个页面能够访问完整的重定向URI，它包含了由user-agent保存的URI片断，同时这个页面能够将包含在URI片断中的访问令牌（和其它参数）提取出来。</p><p>(F) user-agent在本地执行由web服务器提供的脚本，该脚本提取出访问令牌并将它传递给第三方应用平台（client）</p><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>密码模式就是将密码托管给第三方App，但是必须要保证第三方App高度可信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Resource |</span><br><span class="line">|  Owner   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">  |</span><br><span class="line">  |    Resource Owner</span><br><span class="line"> (A) Password Credentials</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |---(B)---- Resource Owner -------&gt;|               |</span><br><span class="line">|         |         Password Credentials     | Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(C)---- Access Token ----------|               |</span><br><span class="line">|         |    (w/ Optional Refresh Token)   |               |</span><br><span class="line">+---------+                                  +---------------+</span><br></pre></td></tr></table></figure><p>(A) 用户向客户端提供用户名和密码。</p><p>(B) 客户端将用户名和密码发给认证服务器，向后者请求令牌。<br>包含以下参数：</p><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>(C) 认证服务器确认无误后，向客户端提供访问令牌。</p><h4 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h4><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |                                  |               |</span><br><span class="line">|         |---(A)- Client Authentication ---&gt;| Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(B)---- Access Token ----------|               |</span><br><span class="line">|         |                                  |               |</span><br><span class="line">+---------+                                  +---------------+</span><br></pre></td></tr></table></figure><p>(A) 客户端向认证服务器进行身份认证，并要求一个访问令牌。<br>包含以下参数：</p><ul><li>granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>(B) 认证服务器确认无误后，向客户端提供访问令牌。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">The OAuth 2.0 Authorization Framework</a></p><p><a href="https://segmentfault.com/a/1190000010540911" target="_blank" rel="noopener">理解OAuth2.0认证与客户端授权码模式详解</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;信任问题&quot;&gt;&lt;a href=&quot;#信任问题&quot; class=&quot;headerlink&quot; title=&quot;信任问题&quot;&gt;&lt;/a&gt;信任问题&lt;/h3&gt;&lt;p&gt;在OAuth2.0中，简单来说有三方：用户（指属于服务方的用户）、服务方（如微信、微博等）、第三方应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="OAuth" scheme="/tags/OAuth/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation</title>
    <link href="/2019/11/07/cloudFormation/"/>
    <id>/2019/11/07/cloudFormation/</id>
    <published>2019-11-07T15:06:12.000Z</published>
    <updated>2019-11-11T16:39:46.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><a id="more"></a><p>AWS CloudFormation 是一项服务，可对 Amazon Web Services 资源进行建模和设置，花较少的时间管理这些资源，将更多的时间花在运行于 AWS 中的应用程序上。创建一个描述所需的所有 AWS 资源（如 Amazon EC2 实例或 Amazon RDS 数据库实例）的模板，并且 AWS CloudFormation 将负责设置和配置这些资源。无需单独创建和配置 AWS 资源， AWS CloudFormation 句柄处理工作时所依赖的内容。</p><ul><li><p>模板 （template）</p><blockquote><p>CloudFormation 模板是 JSON 或 YAML 格式的文本文件。可以使用任何扩展名（如 .json、.yaml、.template 或 .txt）保存这些文件。CloudFormation 将这些模板作为蓝图以构建 AWS 资源。<br>可以在单个模板中指定多种资源并将这些资源配置结合使用</p></blockquote></li><li><p>堆栈（stack）</p><blockquote><p>在使用 CloudFormation 时，可将相关资源作为一个称为“堆栈”的单元进行管理。可通过创建、更新和删除堆栈来管理一组资源。堆栈中的所有资源均由 CloudFormation 模板定义。假设创建了一个模板，它包括 Auto Scaling 组、Elastic Load Balancing 负载均衡器和 Amazon Relational Database Service (Amazon RDS) 数据库实例。要创建这些资源，可通过提交已创建的模板来创建堆栈，CloudFormation 将会配置所有这些资源。</p></blockquote></li><li><p>更改集（change set）</p><blockquote><p>如果需要更改堆栈中运行的资源，可更新堆栈。在更改资源前，您可以生成一个更改集，这是修改内容的概括。利用更改集，您可以在实施更改之前，了解更改可能会对运行的资源造成的影响。</p></blockquote></li></ul><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><h5 id="资源（resource）"><a href="#资源（resource）" class="headerlink" title="资源（resource）"></a>资源（resource）</h5><p>Resources对象包含一系列资源对象，一个资源需要声明资源的属性，且必须有一个Type属性，该属性规定了要创建AWS资源的类别。该Type属性有一个特殊格式：</p><blockquote><p>AWS::ProductIdentifier::ResourceType</p></blockquote><p>For example: resource type for an Amazon S3 bucket</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Resources"</span> : &#123;</span><br><span class="line">        <span class="attr">"HelloBucket"</span> : &#123;</span><br><span class="line">            <span class="attr">"Type"</span> : <span class="string">"AWS::S3::Bucket"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>YAML:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  HelloBucket:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="attr">AWS::S3::Bucket</span></span><br></pre></td></tr></table></figure><p>根据资源类型，一些属性是必需的，而其他属性是可选的。</p><ul><li>资源属性（properties）和共同使用资源</li></ul><p>有些资源可以有多个属性，有些属性可以有多个子属性，例如，AWS::S3::Bucket 资源具有两个属性，即 AccessControl 和 WebsiteConfiguration。WebsiteConfiguration 属性有 IndexDocument 和 ErrorDocument 两个子属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  HelloBucket:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="attr">AWS::S3::Bucket</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      AccessControl:</span> <span class="string">PublicRead</span> <span class="string">（指代了一个已存在的</span> <span class="string">ACL）</span></span><br><span class="line"><span class="attr">      WebsiteConfiguration:</span></span><br><span class="line"><span class="attr">        IndexDocument:</span> <span class="string">index.html</span></span><br><span class="line"><span class="attr">        ErrorDocument:</span> <span class="string">error.html</span></span><br></pre></td></tr></table></figure><p>Ref funtion:<br>set properties on one resource based on the name or property of another resource, can use the <code>Ref function</code> to refer to an identifying property of a resource<br>例如，创建一个 AWS::EC2::Instance 资源，该资源的 SecurityGroups 属性调用了 Ref 函数，以便能调用 AWS::EC2::SecurityGroup 资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  Ec2Instance:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::Instance'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      SecurityGroups:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="type">!Ref</span> <span class="string">InstanceSecurityGroup</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">MyExistingSecurityGroup</span> <span class="string">（指代现存的</span> <span class="string">EC2</span> <span class="string">安全组）</span></span><br><span class="line"><span class="attr">      KeyName:</span> <span class="string">mykey</span></span><br><span class="line"><span class="attr">      ImageId:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  InstanceSecurityGroup:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::SecurityGroup'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">via</span> <span class="string">port</span> <span class="number">22</span></span><br><span class="line"><span class="attr">      SecurityGroupIngress:</span></span><br><span class="line"><span class="attr">        - IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line"><span class="attr">          FromPort:</span> <span class="string">'22'</span></span><br><span class="line"><span class="attr">          ToPort:</span> <span class="string">'22'</span></span><br><span class="line"><span class="attr">          CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br></pre></td></tr></table></figure><p>Ref 函数可指代那些在创建堆栈时指定的输入参数（Parameters），以下模板添加了一个 KeyName 参数对象，参数类型为 AWS::EC2::KeyPair::KeyName</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Parameters:</span></span><br><span class="line"><span class="attr">  KeyName:</span></span><br><span class="line"><span class="attr">    Description:</span> <span class="string">The</span> <span class="string">EC2</span> <span class="string">Key</span> <span class="string">Pair</span> <span class="string">to</span> <span class="string">allow</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">the</span> <span class="string">instance</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::KeyPair::KeyName'</span></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  Ec2Instance:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::Instance'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      SecurityGroups:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="type">!Ref</span> <span class="string">InstanceSecurityGroup</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">MyExistingSecurityGroup</span></span><br><span class="line"><span class="attr">      KeyName:</span> <span class="type">!Ref</span> <span class="string">KeyName</span></span><br><span class="line"><span class="attr">      ImageId:</span> <span class="string">ami-7a11e213</span></span><br><span class="line"><span class="attr">  InstanceSecurityGroup:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::SecurityGroup'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">via</span> <span class="string">port</span> <span class="number">22</span></span><br><span class="line"><span class="attr">      SecurityGroupIngress:</span></span><br><span class="line"><span class="attr">        - IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line"><span class="attr">          FromPort:</span> <span class="string">'22'</span></span><br><span class="line"><span class="attr">          ToPort:</span> <span class="string">'22'</span></span><br><span class="line"><span class="attr">          CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br></pre></td></tr></table></figure><p>Fn::GetAtt:<br>返回模板中的资源的属性值，FN::GetAtt 函数有两个参数，资源的逻辑名和要检索的属性名<br>示例代码返回 myELB 资源的 DNS 属性名称。<br>json:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"Fn::GetAtt" : [ "myELB" , "DNSName" ]</span><br></pre></td></tr></table></figure><p>yaml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!GetAtt</span> <span class="string">myELB.DNSName</span></span><br></pre></td></tr></table></figure><ul><li>Parameters</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Parameters:</span></span><br><span class="line"><span class="attr">  KeyName:</span></span><br><span class="line"><span class="attr">    Description:</span> <span class="string">Name</span> <span class="string">of</span> <span class="string">an</span> <span class="string">existing</span> <span class="string">EC2</span> <span class="string">KeyPair</span> <span class="string">to</span> <span class="string">enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">into</span> <span class="string">the</span> <span class="string">WordPress</span> <span class="string">web</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="attr">AWS::EC2::KeyPair::KeyName</span></span><br><span class="line"><span class="attr">  WordPressUser:</span></span><br><span class="line"><span class="attr">    Default:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">    NoEcho:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    Description:</span> <span class="string">The</span> <span class="string">WordPress</span> <span class="string">database</span> <span class="string">admin</span> <span class="string">account</span> <span class="string">user</span> <span class="string">name</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">String</span></span><br><span class="line"><span class="attr">    MinLength:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    MaxLength:</span> <span class="number">16</span></span><br><span class="line"><span class="attr">    AllowedPattern:</span> <span class="string">"[a-zA-Z][a-zA-Z0-9]*"</span></span><br><span class="line"><span class="attr">  WebServerPort:</span></span><br><span class="line"><span class="attr">    Default:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">    Description:</span> <span class="string">TCP/IP</span> <span class="string">port</span> <span class="string">for</span> <span class="string">the</span> <span class="string">WordPress</span> <span class="string">web</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">Number</span></span><br><span class="line"><span class="attr">    MinValue:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    MaxValue:</span> <span class="number">65535</span></span><br></pre></td></tr></table></figure><p>参数可以有默认值，string类型可以指定MinLength、MaxLength、Default、AllowedValues 和 AllowedPattern；Number类型可以指定MinValue、MaxValue、Default 和 AllowedValues；NoEcho 属性属性让参数值不显示在控制台、命令行工具或 API 上，设置为 true将以星号的形式返回参数值</p><ul><li>使用映射（Mappings）指定条件型值</li></ul><p>可能会有一些根据区域而定的配置，例如 ImageId 属性写为固定的AMI ID在美国东部区域可正常使用，但用户尝试在不同区域的创建堆栈，那么将会得到一个错误的 AMI ID或得不到，因为AMI ID 对一个区域来说是唯一的，但在不同的区域同一个 AMI ID 代表内容不同，因此可使用AWS::Region 与 Mappings 对象结合，为每一个区域设置一个适当的 AMI ID</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Parameters:</span></span><br><span class="line"><span class="attr">  KeyName:</span></span><br><span class="line"><span class="attr">    Description:</span> <span class="string">Name</span> <span class="string">of</span> <span class="string">an</span> <span class="string">existing</span> <span class="string">EC2</span> <span class="string">KeyPair</span> <span class="string">to</span> <span class="string">enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">the</span> <span class="string">instance</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">String</span></span><br><span class="line"><span class="attr">Mappings:</span></span><br><span class="line"><span class="attr">  RegionMap:</span></span><br><span class="line"><span class="attr">    us-east-1:</span></span><br><span class="line"><span class="attr">      AMI:</span> <span class="string">ami-76f0061f</span></span><br><span class="line"><span class="attr">    us-west-1:</span></span><br><span class="line"><span class="attr">      AMI:</span> <span class="string">ami-655a0a20</span></span><br><span class="line"><span class="attr">    eu-west-1:</span></span><br><span class="line"><span class="attr">      AMI:</span> <span class="string">ami-7fd4e10b</span></span><br><span class="line"><span class="attr">    ap-southeast-1:</span></span><br><span class="line"><span class="attr">      AMI:</span> <span class="string">ami-72621c20</span></span><br><span class="line"><span class="attr">    ap-northeast-1:</span></span><br><span class="line"><span class="attr">      AMI:</span> <span class="string">ami-8e08a38f</span></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  Ec2Instance:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::Instance'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      KeyName:</span> <span class="type">!Ref</span> <span class="string">KeyName</span></span><br><span class="line"><span class="attr">      ImageId:</span> <span class="type">!FindInMap</span> </span><br><span class="line"><span class="bullet">        -</span> <span class="string">RegionMap</span></span><br><span class="line"><span class="bullet">        -</span> <span class="type">!Ref</span> <span class="string">'AWS::Region'</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">AMI</span></span><br><span class="line"><span class="attr">      UserData:</span> <span class="type">!Base64</span> <span class="string">'80'</span></span><br></pre></td></tr></table></figure><ul><li>Fn::Join</li></ul><p>可能存在参数值仅仅是所需值的一部分的情况，这时就需要对参数值进行拼接，以便形成所需值<br>函数有两个参数，一个是值的分隔符，另一个是按这些值出现的顺序排列的数组<br>例如 WebServerPort 值为 8888，目标属性将为：HTTP:8888/</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Target:</span> <span class="type">!Join</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">''</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">-</span> <span class="string">'HTTP:'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="type">!Ref</span> <span class="string">WebServerPort</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h4 id="AWS-CLI"><a href="#AWS-CLI" class="headerlink" title="AWS CLI"></a>AWS CLI</h4><ul><li>创建堆栈: </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation create-stack</span><br></pre></td></tr></table></figure><p>必须提供堆栈名称、有效模板的位置和所有输入参数,参数以空格分隔，键名称区分大小写<br>注：如果指定了一个本地模板文件，则 CloudFormation 会将该文件上传到您的 AWS 账户中的 Amazon S3 存储桶</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation create-stack --stack-name myteststack --template-body file:///home/testuser/mytemplate.json</span><br></pre></td></tr></table></figure><ul><li>描述并列出堆栈</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation list-stacks</span><br><span class="line">aws cloudformation describe-stacks</span><br></pre></td></tr></table></figure><p>使用 aws cloudformation list-stacks 命令可以获取已创建的任何堆栈的列表 (甚至包括已在90天内删除的堆栈)。可以使用选项按堆栈状态 (如 CREATE_COMPLETE 和 DELETE_COMPLETE) 筛选结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE</span><br></pre></td></tr></table></figure><p>aws cloudformation describe-stacks 命令提供正在运行的堆栈的相关信息。可以使用选项按堆栈名称筛选结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation describe-stacks --stack-name myteststack</span><br></pre></td></tr></table></figure><ul><li>列出资源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation list-stack-resources --stack-name myteststack</span><br></pre></td></tr></table></figure><p>列出资源, 该命令将列出您使用 –stack-name 参数指定的堆栈中的每个资源的汇总信息<br>注：aws cloudformation describe-stack-resources 命令可返回90天内删除的堆栈的信息</p><ul><li>检索模板</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation get-template --stack-name myteststack</span><br></pre></td></tr></table></figure><p>模板存储为堆栈的一部分,可返回90天内删除的模板信息</p><ul><li>验证模板</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation validate-template</span><br></pre></td></tr></table></figure><p>检查您的模板文件是否存在语法错误<br>在验证期间，首先检查模板是否是有效的 JSON。如果不是，CloudFormation 会检查模板是否是有效的 YAML。如果两种检查都失败，CloudFormation 返回模板验证错误。可以使用 <code>--template-body</code> 参数在本地验证模板，也可以使用 <code>--template-url</code> 参数进行远程验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation validate-template --template-url https://s3.amazonaws.com/cloudformation-templates-us-east-1/S3_Bucket.template</span><br></pre></td></tr></table></figure><ul><li>删除堆栈</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation delete-stack --stack-name myteststack</span><br></pre></td></tr></table></figure><h4 id="堆栈更新"><a href="#堆栈更新" class="headerlink" title="堆栈更新"></a>堆栈更新</h4><p>CloudFormation 会对比提交的内容与堆栈当前模板来更新资源。未更改的资源在更新过程中不中断。对于更新后的资源，CloudFormation 可能使用下列更新行为：</p><ul><li>Update with No Interruption</li></ul><p>CloudFormation 在更新资源时不中断该资源，同时不改变资源物理 ID。例如：更新AWS::CloudTrail::Trail将不会打断资源运行</p><ul><li>Updates with Some Interruption</li></ul><p>CloudFormation 更新资源时会中断，并且保留物理 ID。例如对 AWS::EC2::Instance 资源更新特定属性，则在 CloudFormation 和 EC2 重新配置实例期间，该实例可能会中断。</p><ul><li>Replacement<br>CloudFormation 在更新过程中重新创建资源，这还会生成新的物理 ID。CloudFormation 会先创建替换资源，将其他相关资源的引用变为指向替换资源，然后删除旧资源。例如，如果更新 AWS::RDS::DBInstance 资源类型的 Engine 属性，则 AWS CloudFormation 会创建新资源并将当前数据库实例资源替换为新资源。</li></ul><p>CloudFormation 使用的更新行为取决于要更新的资源属性。 <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html" target="_blank" rel="noopener">AWS Resource Types Reference</a> 介绍了每个属性的更新行为。</p><h5 id="使用更改集更新堆栈"><a href="#使用更改集更新堆栈" class="headerlink" title="使用更改集更新堆栈"></a>使用更改集更新堆栈</h5><p>使用更改集可以预览更改对正在运行的资源造成什么影响，例如，无论更改是否会删除或替换任何关键资源，只有在决定执行更改集时，CloudFormation 才会对堆栈进行更改，这样可以决定是否继续执行更改，还是通过创建另一个更改集来探索其他更改。</p><p>how to use change set to update a stack:<br><img src="/2019/11/07/cloudFormation/56C876CF-CF0B-458E-9F4D-5E604F746D6F.png" alt></p><p>1.通过为堆栈提交更改来创建更改集。您可以提交修改后的stack template或者修改后的输入参数值。CloudFormation 将堆栈与所提交更改进行对比，生成更改集；此时不会更改堆栈。</p><p>2.查看更改集以了解将更改哪些堆栈设置和资源。例如，可以查看CloudFormation 将添加、修改或删除哪些资源。</p><p>3.可选：如果想在决定更改之前考虑其他更改，请创建其他的更改集。创建多个更改集可了解和评估不同的更改对资源会造成什么影响，可以根据需要创建任意数量的更改集。</p><p>4.执行希望应用到堆栈的更改集。CloudFormation 使用这些更改更新您的堆栈。</p><p>注：执行更改后，CloudFormation 将删除与堆栈关联的所有更改集</p><ul><li>创建更改集</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation create-change-set</span><br></pre></td></tr></table></figure><p>指定新参数值和/或修改后的模板。以下命令为 SampleChangeSet 堆栈创建名为 SampleStack 的更改集。更改集使用当前堆栈的模板，但 Purpose 参数具有不同值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation create-change-set --stack-name arn:aws:cloudformation:us-east-1:123456789012:stack/SampleStack/1a2345b6-0000-00a0-a123-00abc0abc000</span><br><span class="line">--change-set-name SampleChangeSet --use-previous-template --parameters ParameterKey=<span class="string">"InstanceType"</span>,UsePreviousValue=<span class="literal">true</span> ParameterKey=<span class="string">"KeyPairName"</span>,UsePreviousValue=<span class="literal">true</span> ParameterKey=<span class="string">"Purpose"</span>,ParameterValue=<span class="string">"production"</span></span><br></pre></td></tr></table></figure><ul><li>查看更改集</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation list-change-sets --stack-name arn:aws:cloudformation:us-east-1:123456789012:stack/SampleStack/1a2345b6-0000-00a0-a123-00abc0abc000</span><br><span class="line">(stack id)</span><br><span class="line"></span><br><span class="line">aws cloudformation describe-change-set --change-set-name arn:aws:cloudformation:us-east-1:123456789012:changeSet/SampleChangeSet/1a2345b6-0000-00a0-a123-00abc0abc000</span><br><span class="line">(change <span class="built_in">set</span> id)</span><br></pre></td></tr></table></figure><ul><li>执行更改集 (change set id)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation execute-change-set --change-set-name arn:aws:cloudformation:us-east-1:123456789012:changeSet/SampleChangeSet/1a2345b6-0000-00a0-a123-00abc0abc000</span><br></pre></td></tr></table></figure><ul><li>删除更改集 (change set id)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation delete-change-set --change-set-name arn:aws:cloudformation:us-east-1:123456789012:changeSet/SampleChangeSet/1a2345b6-0000-00a0-a123-00abc0abc000</span><br></pre></td></tr></table></figure><ul><li>直接更新堆栈</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws cloudformation update-stack --stack-name mystack --template-url https://s3.amazonaws.com/sample/updated.template</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>当创建堆栈时，CloudFormation 对 AWS 基础服务调用配置资源。CloudFormation 只能执行有执行权限的操作。例如，要使用 CloudFormation 创建 EC2 实例，需要具有创建实例的权限。可以使用 Identity and Access Management (IAM) 管理权限。</p><p>CloudFormation 进行的调用全部由模板声明</p><p><img src="/2019/11/07/cloudFormation/BA8B245C-410A-4657-B803-48EB29A2EAE8.png" alt></p><ul><li>更改集更新堆栈</li></ul><p>更新堆栈的资源，不需要创建新堆栈和删除旧堆栈</p><p><img src="/2019/11/07/cloudFormation/EB5E28F6-D3B2-4CB4-9484-6F7D06074D34.png" alt></p><p>注：更改集并不指示堆栈更新是否会成功。例如，更改集不检查是否将超出账户限制、是否将更新不支持更新的资源或者权限不足而无法修改资源，这些都将导致堆栈更新失败。</p><ul><li>删除堆栈</li></ul><p>在删除堆栈时，可指定要删除的堆栈，CloudFormation 将删除该堆栈及其包含的所有资源<br>若要删除一个堆栈但保留该堆栈中的一些资源，可使用删除策略来保留那些资源</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ul><li>使用 IAM 控制访问</li></ul><p>可以创建 IAM 用户以控制谁有权访问 AWS 账户中的哪些资源。可以将 IAM 与 CloudFormation 结合以控制用户使用 CloudFormation 执行操作，例如，是否可以查看堆栈模板、创建堆栈或删除堆栈。</p><p>When you create a group or an IAM user in your AWS account, you can associate an IAM policy with that group or user, which specifies the permissions that you want to grant. </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Version"</span>:<span class="string">"2012-10-17"</span>,</span><br><span class="line">    <span class="attr">"Statement"</span>:[&#123;</span><br><span class="line">        <span class="attr">"Effect"</span>:<span class="string">"Allow"</span>,</span><br><span class="line">        <span class="attr">"Action"</span>:[</span><br><span class="line">            <span class="string">"cloudformation:DescribeStacks"</span>,</span><br><span class="line">            <span class="string">"cloudformation:DescribeStackEvents"</span>,</span><br><span class="line">            <span class="string">"cloudformation:DescribeStackResource"</span>,</span><br><span class="line">            <span class="string">"cloudformation:DescribeStackResources"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"Resource"</span>:<span class="string">"*"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注：If you don’t specify a stack name or ID in your statement, you must also grant the permission to use all resources for the action using the * wildcard for the Resource element.</p><ul><li>CloudFormation 资源</li></ul><p>CloudFormation 支持资源级权限，因此可以指定针对特定堆栈的操作。如拒绝MyProductionStack 的删除和更新堆栈操作的策略示例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Version"</span>:<span class="string">"2012-10-17"</span>,</span><br><span class="line">    <span class="attr">"Statement"</span>:[&#123;</span><br><span class="line">        <span class="attr">"Effect"</span>:<span class="string">"Deny"</span>,</span><br><span class="line">        <span class="attr">"Action"</span>:[</span><br><span class="line">            <span class="string">"cloudformation:DeleteStack"</span>,</span><br><span class="line">            <span class="string">"cloudformation:UpdateStack"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"Resource"</span>:<span class="string">"arn:aws:cloudformation:us-east-1:123456789012:stack/MyProductionStack/*"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CloudFormation 条件</li></ul><p>可以指定控制策略何时生效</p><p>AWS::*<br>指定所有 AWS 资源。</p><p>AWS::service_name::*<br>指定用于特定 AWS 服务的所有资源。</p><p>AWS::service_name::resource_type<br>指定特定的 AWS 资源类型，如 AWS::EC2::Instance (所有 EC2 实例)。</p><p>Custom::*<br>指定所有自定义资源。</p><p>Custom::resource_type<br>指定特定的自定义资源类型 (在模板中定义)。</p><p>cloudformation:RoleARN<br>Use this condition to control which service role IAM users can use when they work with stacks or change sets.</p><p>cloudformation:StackPolicyUrl<br>在创建或更新堆栈操作期间，使用此条件控制 IAM 用户可将哪些堆栈policy关联到堆栈 。</p><p>cloudformation:TemplateUrl<br>与策略关联的 S3 模板 URL。使用此条件控制 IAM 用户在创建或更新堆栈时可以使用的模板。</p><p>示例中用户只能使用 <a href="https://s3.amazonaws.com/testbucket/test.template" target="_blank" rel="noopener">https://s3.amazonaws.com/testbucket/test.template</a> 模板 URL 创建或更新堆栈。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>:<span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span> : <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Action"</span> : [ </span><br><span class="line">      <span class="string">"cloudformation:CreateStack"</span>,</span><br><span class="line">      <span class="string">"cloudformation:UpdateStack"</span> ],</span><br><span class="line">      <span class="attr">"Resource"</span> : <span class="string">"*"</span>,</span><br><span class="line">      <span class="attr">"Condition"</span> : &#123;</span><br><span class="line">        <span class="attr">"ForAllValues:StringEquals"</span> : &#123;</span><br><span class="line">          <span class="attr">"cloudformation:TemplateUrl"</span> : [ <span class="string">"https://s3.amazonaws.com/testbucket/test.template"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2019/10/10/linux/"/>
    <id>/2019/10/10/linux/</id>
    <published>2019-10-10T02:23:04.000Z</published>
    <updated>2019-10-10T03:16:54.256Z</updated>
    
    <content type="html"><![CDATA[<p>man 命令名    #查看命令的详细说明<br>命令名 -help   #查看命令的常用选项</p><a id="more"></a><p><strong>1 下载与安装</strong></p><p>下载：</p><pre><code>wget url #下载文件 （wget 命令常用于下载）curl www.baidu.com #请求指定网址并显示 （curl 命令可用于各种请求方式，常用于上传与请求）</code></pre><p>安装：解压缩 （如：<span style="color: rgb(0, 0, 0);">tar -xzvf soft.tar.gz），进入解压后的文件夹</span></p><pre><code>./configure（生成makefile文件）makemake install</code></pre><p><strong>2 文件命令</strong></p><p>创建文件：touch 文件名</p><p>删除文件：rm -rf 文件名  #r代表递归，f代表强制删除</p><p>查看文件：</p><p><img src="/2019/10/10/linux/file.png" alt></p><p>建立软连接：ln -s 源文件 目标文件</p><pre><code>#文件名都必须写绝对路径#删除了源文件，那么目标文件就会被标识为红色，但仍指向源文件；重新新建源文件，目标文件依然可用</code></pre><p>比较文件差异：diff 选项 文件一  文件二</p><p><strong>3 目录操作</strong></p><p><img src="/2019/10/10/linux/dir.png" alt></p><p><strong>4 文件和目录操作</strong></p><p><img src="/2019/10/10/linux/file-and-dir.png" alt></p><p>更改用户：sudo chown -R $USER /usr/local/lib/node_modules</p><p><strong>5 权限管理</strong></p><p><img src="/2019/10/10/linux/right.png" alt></p><p><strong>6 压缩解压</strong></p><p><img src="/2019/10/10/linux/compress.png" alt></p><p><strong>7 查找搜索</strong></p><p><img src="/2019/10/10/linux/find.png" alt></p><p><strong>8 SSH</strong></p><p>ssh [-p port] user@remote</p><pre><code>user 是在远程机器上的用户名，如果不指定的话默认为当前用户remote 是远程机器的地址，可以是IP/域名，或者是别名port 是SSH Server监听的端口，如果不指定，就为默认值22(使用exit退出当前用户的登录)</code></pre><p>设置ssh密钥：ssh-keygen</p><p>上传公钥到服务器：</p><pre><code>ssh-copy-id -p port user@remote（ssh-copy-id -p 22 deepin2@192.168.56.132）让远程服务器记住密钥，之后免密登陆</code></pre><p><strong>9 快捷键</strong></p><p><img src="/2019/10/10/linux/shortcut.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;man 命令名    #查看命令的详细说明&lt;br&gt;命令名 -help   #查看命令的常用选项&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用命令" scheme="/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>git常见命令</title>
    <link href="/2019/10/10/git/"/>
    <id>/2019/10/10/git/</id>
    <published>2019-10-09T17:57:55.000Z</published>
    <updated>2019-10-10T14:28:22.321Z</updated>
    
    <content type="html"><![CDATA[<p>git基本使用流程：   </p><a id="more"></a><pre><code>git add [files]git commitgit pull --rebase ( if conflicts happen, resolve merge conflicts )git rebase --continuegit push</code></pre><p>在任何时候，都可以用git rebase –abort参数来终止rebase的行动，并且分支会回到rebase开始前的状态。</p><pre><code>git pull = git fetch + git mergegit pull --rebase = git fetch + git rebase</code></pre><p><strong>1 切换分支</strong>： git checkout [branch name]</p><pre><code>git checkout -- a.txt   # 丢弃某个文件修改git checkout -- .       # 丢弃全部</code></pre><p>创建分支 git branch [branch name]</p><p>切换并生成分支 git checkout -b [branch name]</p><p><strong>2 合并分支</strong>：切换到主分支，使用 git merge / git rebase</p><p>假设目前存在两个分支master、bugfix<br><img src="/2019/10/10/git/two-branches.png" alt></p><p>使用git merge，合并两个修改会生成一个提交，master分支的HEAD会移动到该提交上。<br><img src="/2019/10/10/git/git-merge.png" alt></p><p>git rebase bugfix分支到master分支, bugfix分支的历史记录会添加在master分支的后面。<br><img src="/2019/10/10/git/git-rebase.png" alt></p><p><strong>3 添加远程库</strong>：git remote add origin [repo name]</p><pre><code>git push -u origin master= git push origin master ; git branch --set-upstream master origin/master</code></pre><blockquote><p> 使用-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来<br>–set-upstream：sets the default remote branch for the current local branch.</p></blockquote><p><strong>4 版本回退</strong>：假设C 和 D 是错误提交<br><img src="/2019/10/10/git/error-sumbit.png" alt></p><p><strong>git reset:</strong></p><ul><li><p>Use this to <strong>return</strong> the <em>entire</em> working tree to the last committed state. <em>This will discard commits in a private branch or throw away uncommitted changes!</em></p></li><li><p>Changes which commit a branch HEAD is currently pointing at. It alters the existing commit history.</p><blockquote><p>如果使用：git reset –hard a0fvf8；失去C和D的提交信息</p></blockquote></li></ul><p><img src="/2019/10/10/git/git-reset.png" alt></p><pre><code>git reset --soft xxx：只回退commit，如果你想再次提交直接git commit即可git reset --hard xxx：彻底回退版本，连本地文件都会被回退到上个版本的内容</code></pre><p><strong>git revert :</strong></p><ul><li><p><strong>Rollback changes</strong> you have committed.</p></li><li><p>Creates a <strong>new commit</strong> from a specified commit by inverting it. Hence, adds a new commit history to the project, but it does not modify the existing one.</p><blockquote><p>先 revert D，再 revert C<br>git revert 5lk4er; git revert 76sdeb<br>生成两个新有提交：D’ 和 C’,错误的提交 C 和 D 依然保留</p></blockquote></li></ul><p><img src="/2019/10/10/git/git-revert.png" alt></p><p>revert多个提交</p><pre><code>git revert OLDER_COMMIT^..NEWER_COMMIT （git revert B^..D -&gt; revert B,C,D）</code></pre><blockquote><p>如果不想三个revert生成三个新的commit，而是用一个commit完成，可以：<br>git revert -n OLDER_COMMIT^..NEWER_COMMIT<br>git commit -m “revert OLDER_COMMIT to NEWER_COMMIT”</p></blockquote><p>eg: 错误提交位于中间,直接使用 git reset 命令将 HEAD 指针重置到 A 提交显然是不行的，因为 C 提交是正确的，需要保留的。</p><p><img src="/2019/10/10/git/eg1.png" alt></p><p>推荐做法：先把 C 提交 及 B 提交全部回退，再使用 cherry-pick 命令将 C 提交重新再生成一个新的提交 C’</p><p><img src="/2019/10/10/git/eg2.png" alt></p><p><strong>5 cherry-pick：</strong></p><p><img src="/2019/10/10/git/cherry-pick.png" alt></p><p>只将C2合并到master，丢弃C3的修改</p><ul><li><p>用git log查看C2 commit的id</p></li><li><p>git checkout 到master分支下</p></li><li><p>git cherry-pick <c2_id></c2_id></p></li></ul><p>如果出现冲突，</p><ul><li><p>先解决冲突</p></li><li><p>git add 将解决了冲突的文件添加到暂存区</p></li><li><p>git cherry-pick –continue</p></li></ul><p><strong>6 git reflog：</strong></p><p>可以查看所有分支的所有操作记录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git基本使用流程：   &lt;/p&gt;
    
    </summary>
    
    
      <category term="常用命令" scheme="/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>docker 基本概念与命令</title>
    <link href="/2019/10/09/docker/"/>
    <id>/2019/10/09/docker/</id>
    <published>2019-10-09T15:07:19.000Z</published>
    <updated>2019-10-10T06:24:58.761Z</updated>
    
    <content type="html"><![CDATA[<p>docker / docker-compose 相关概念及常用命令</p><a id="more"></a><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><hr><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="- 基本概念"></a>- <strong>基本概念</strong></h6><p>Docker是一种容器，操作系统级别的轻量级虚拟化，可以把环境一起打包扔给各服务器，随时随地都能运行。（保证运行环境一致）</p><p>Docker镜像（image）：相当于root文件系统，内核启动后为其提供用户空间支持。<br>除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker容器（container）：实质是进程，镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，image是container的静态定义（可类比 hello_world.py文件 和 对应的hello_world进程），容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>Docker Register：镜像构建完成后，如果需要在其它服务器上使用，那么就需要一个集中的存储、分发镜像的服务<br>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像<br>通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像</p><h6 id="常用命令"><a href="#常用命令" class="headerlink" title="- 常用命令"></a>- <strong>常用命令</strong></h6><p><strong>1. 镜像</strong></p><p>&lt;1&gt; 获取镜像：docker pull [选项] [Docker Registry 地址 [:端口号] /] 仓库名 [:标签]</p><pre><code>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。仓库名： &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</code></pre><p>&lt;2&gt;列出镜像：docker image ls</p><pre><code>查看中间层镜像：docker image ls -a列出部分镜像：       根据仓库名列出镜像：docker image ls ubuntu       指定仓库名和标签：docker image ls ubuntu:18.04       过滤器参数（--filter）：docker image ls -f since=mongo:3.2 （mongo:3.2之后的镜像）       以特定格式显示（-q/--format）：docker image ls --format &quot;{{.ID}} : {{.Repository}}&quot;</code></pre><p>&lt;3&gt;删除虚悬镜像：docker image prune</p><p>&lt;4&gt;删除本地镜像：docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p><pre><code>配合 ls使用：docker image rm $(docker image ls -q redis)    （删除所有仓库名为redis的镜像）docker image rm $(docker image ls -q -f before=mongo:3.2)。（删除所有在mongo:3.2之前的镜像）</code></pre><p>&lt;5&gt;运行容器时修改了文件，保存成最终镜像：<br>docker commit [选项]&lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]]   （慎用，黑箱镜像）</p><pre><code>eg：docker commit --author &quot;Tao Wang &lt;[twang2218@gmail.com](mailto:twang2218@gmail.com)&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</code></pre><p>&lt;6&gt;定制镜像：Dockerfile</p><pre><code>一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 From指定基础镜像，Run 执行命令 构建镜像：docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p><strong>2. 容器</strong></p><p>&lt;1&gt;新建并启动：docker run</p><p>&lt;2&gt;启动已终止容器：docker container start [container ID or NAMES]</p><p>&lt;3&gt;后台运行(-d): </p><pre><code>docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done”</code></pre><p>&lt;4&gt;查看容器信息：docker container ls</p><p>&lt;5&gt; 获取容器的输出信息：docker container logs [container ID or NAMES]</p><p>&lt;6&gt;终止容器：docker container stop [container ID or NAMES]</p><p>&lt;7&gt;重启运行中的容器：docker container restart [container ID or NAMES]</p><p>&lt;8&gt;进入容器：docker attach [container ID or NAMES]  (从 stdin 中 exit，会导致容器停止)</p><pre><code>docker exec -it [container ID or NAMES] bash (从 stdin 中 exit，不会导致容器停止，推荐)&gt; -I: interactive, keep stdin -iopen&gt; -t: 分配伪终端</code></pre><p>&lt;9&gt;导出容器：docker export [container ID] &gt; ubuntu.tar</p><p>&lt;10&gt;导入容器：cat ubuntu.tar | docker import - test/ubuntu:v1.0</p><p>&lt;11&gt;删除容器：docker container rm [container ID or NAMES] （运行中的容器可使用-f参数）</p><p>&lt;12&gt;清理所有处于终止状态的容器：docker container prune</p><p><strong>3. 仓库</strong></p><p>&lt;1&gt;查找官方仓库中的镜像：docker search</p><p>&lt;2&gt;推送镜像到 Docker Hub：docker push</p><p><strong>4. 数据管理</strong></p><p>&lt;1&gt;数据卷</p><pre><code>创建：docker volume create my-vol查看：docker volume ls启动一个挂载数据卷的容器（--mount）：docker run -d -P \                                 --name web \                                 --mount source=my-vol,target=/webapp \                                 training/webapp \                                 python [app.py](http://app.py/)（创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。） 查看数据卷的具体信息：docker inspect web 删除数据卷：docker volume rm my-vol</code></pre><p><strong>5. 使用网络</strong></p><p>&lt;1&gt;外部访问容器（-P/-p）：docker run -d -P training/webapp python <a href="http://app.py/" target="_blank" rel="noopener">app.py</a><br>                       (使用-P标记时，Docker 会随机映射一个49000~49900的端口到内部容器开放的网络端口)</p><pre><code>docker run -d -p 5000:5000 training/webapp python [app.py](http://app.py/) (本地的5000 端口映射到容器的5000 端口)127.0.0.1:5000:5000  指定地址到指定端口 / 127.0.0.1::5000 指定地址的任意端口 / 127.0.0.1:5000:5000/udp 指定 udp 端口-p可以多次使用来绑定多个端口</code></pre><p>&lt;2&gt;查看映射端口配置：docker port nostalgic_morse 5000</p><p>&lt;3&gt; 新建网络：docker network create -d bridge my-net</p><pre><code>&gt; -d 参数指定 Docker 网络类型，有 bridge、overlay</code></pre><p>&lt;4&gt;连接容器：</p><pre><code>docker run -it --rm --name busybox1 --network my-net busybox sh （运行一个容器并连接到新建的 my-net 网络）docker run -it --rm --name busybox2 --network my-net busybox sh （再运行一个容器并加入到 my-net 网络）&gt; busybox1 与 busybox2 可相互ping通</code></pre><p>Example :</p><p>1.安装Ubuntu：docker pull ubuntu</p><p>2.run container : docker run -tid –name ubuntu -p 23:22 ubuntu：将新建的docker命名为ubuntu并映射到23端口</p><p>3.查看23号端口是否开启：netstat -apnl | grep 23（linux） /  netstat -AaLlnW ｜grep 23（mac）/  lsof -i:23 (mac)</p><p>4.进入container：docker exec -ti ubuntu /bin/bash  </p><p>5.修改root密码：passwd</p><p>6.更新vim：apt install -y vim （也许需要apt update）</p><p>7.安装openssh-server：  apt install -y openssh-server</p><p>8.修改配置，可使用root登录：vim /etc/ssh/sshd_config ，添加PermitRootLogin yes ；添加UsePAM no</p><p>9.启动ssh：service ssh start</p><p>10.重新进入docker container：ssh root@ip -p 23</p><hr><hr><h4 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h4><hr><h6 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="- 基本概念"></a>- 基本概念</h6><p>定义和运行多个 Docker 容器的应用，允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目</p><pre><code>&gt; 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。&gt; 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</code></pre><p>docker-compose [-f=<arg>…] [options] [COMMAND] [ARGS…]</arg></p><hr><hr><h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><hr><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="/2019/10/09/docker/docker.png" alt></p><p><img src="/2019/10/09/docker/virtualization.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker / docker-compose 相关概念及常用命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用命令" scheme="/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>没有知识的荒原</title>
    <link href="/2019/04/12/welcome/"/>
    <id>/2019/04/12/welcome/</id>
    <published>2019-04-12T07:52:25.000Z</published>
    <updated>2019-10-09T15:01:25.311Z</updated>
    
    <content type="html"><![CDATA[<p>真的</p><a id="more"></a><p>没有意思！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
