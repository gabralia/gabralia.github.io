<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜻蜓队长前来觐见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-10-09T17:10:39.576Z</updated>
  <id>/</id>
  
  <author>
    <name>Jinnew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker 基本概念与常用命令</title>
    <link href="/2019/10/09/docker/"/>
    <id>/2019/10/09/docker/</id>
    <published>2019-10-09T15:07:19.000Z</published>
    <updated>2019-10-09T17:10:39.576Z</updated>
    
    <content type="html"><![CDATA[<p>docker / docker-compose 相关概念及常用命令</p><a id="more"></a><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><hr><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="- 基本概念"></a>- <strong>基本概念</strong></h6><p>Docker是一种容器，操作系统级别的轻量级虚拟化，可以把环境一起打包扔给各服务器，随时随地都能运行。（保证运行环境一致）</p><p>Docker镜像（image）：相当于root文件系统，内核启动后为其提供用户空间支持。<br>除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker容器（container）：实质是进程，镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，image是container的静态定义（可类比 hello_world.py文件 和 对应的hello_world进程），容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>Docker Register：镜像构建完成后，如果需要在其它服务器上使用，那么就需要一个集中的存储、分发镜像的服务<br>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像<br>通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像</p><h6 id="常用命令"><a href="#常用命令" class="headerlink" title="- 常用命令"></a>- <strong>常用命令</strong></h6><p><strong>1. 镜像</strong></p><p><1> 获取镜像：<span style="background-color:  simple;">docker pull [选项] [Docker Registry 地址 [:端口号] /] 仓库名 [:标签]</span></1></p><pre><code>&gt; Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。&gt; 仓库名： &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</code></pre><p><2>列出镜像：docker image ls</2></p><pre><code>查看中间层镜像：docker image ls -a列出部分镜像：       根据仓库名列出镜像：docker image ls ubuntu       指定仓库名和标签：docker image ls ubuntu:18.04       过滤器参数（--filter）：docker image ls -f since=mongo:3.2 （mongo:3.2之后的镜像）       以特定格式显示（-q/--format）：docker image ls --format &quot;{{.ID}} : {{.Repository}}&quot;</code></pre><p><3>删除虚悬镜像：docker image prune</3></p><p><4>删除本地镜像：docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</4></p><pre><code>配合 ls使用：docker image rm $(docker image ls -q redis)    （删除所有仓库名为redis的镜像）docker image rm $(docker image ls -q -f before=mongo:3.2)。（删除所有在mongo:3.2之前的镜像）</code></pre><p><5>运行容器时修改了文件，保存成最终镜像：docker commit [选项]&lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]]   （慎用，黑箱镜像）</5></p><pre><code>eg：docker commit --author &quot;Tao Wang &lt;[twang2218@gmail.com](mailto:twang2218@gmail.com)&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</code></pre><p><6>定制镜像：Dockerfile</6></p><pre><code>一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 From指定基础镜像，Run 执行命令 构建镜像：docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p><strong>2. 容器</strong></p><p><1>新建并启动：docker run</1></p><p><2>启动已终止容器：docker container start [container ID or NAMES]</2></p><p><3>后台运行(-d): docker run -d ubuntu:18.04 /bin/sh -c “while true; do echo hello world; sleep 1; done”</3></p><p><4>查看容器信息：docker container ls</4></p><p><5> 获取容器的输出信息：docker container logs [container ID or NAMES]</5></p><p><6>终止容器：docker container stop [container ID or NAMES]</6></p><p><7>重启运行中的容器：docker container restart [container ID or NAMES]</7></p><p><8>进入容器：docker attach [container ID or NAMES]  (从 stdin 中 exit，会导致容器停止)</8></p><pre><code>docker exec -it [container ID or NAMES] bash (从 stdin 中 exit，不会导致容器停止，推荐)&gt; -I: interactive, keep stdin -iopen&gt; -t: 分配伪终端</code></pre><p><9>导出容器：docker export [container ID] &gt; ubuntu.tar</9></p><p><10>导入容器：cat ubuntu.tar | docker import - test/ubuntu:v1.0</10></p><p><11>删除容器：docker container rm [container ID or NAMES] （运行中的容器可使用-f参数）</11></p><p><12>清理所有处于终止状态的容器：docker container prune</12></p><p><strong>3. 仓库</strong></p><p><1>查找官方仓库中的镜像：docker search</1></p><p><2>推送镜像到 Docker Hub：docker push</2></p><p><strong>4. 数据管理</strong></p><p><1>数据卷</1></p><pre><code>创建：docker volume create my-vol查看：docker volume ls启动一个挂载数据卷的容器（--mount）：docker run -d -P \                                 --name web \                                 --mount source=my-vol,target=/webapp \                                 training/webapp \                                 python [app.py](http://app.py/)（创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。） 查看数据卷的具体信息：docker inspect web 删除数据卷：docker volume rm my-vol</code></pre><p><strong>5. 使用网络</strong></p><p><1>外部访问容器（-P/-p）：<br>docker run -d -P training/webapp python <a href="http://app.py/" target="_blank" rel="noopener">app.py</a> (使用-P标记时，Docker 会随机映射一个49000~49900的端口到内部容器开放的网络端口)</1></p><pre><code>docker run -d -p 5000:5000 training/webapp python [app.py](http://app.py/) (本地的5000 端口映射到容器的5000 端口)127.0.0.1:5000:5000  指定地址到指定端口 / 127.0.0.1::5000 指定地址的任意端口 / 127.0.0.1:5000:5000/udp 指定 udp 端口-p可以多次使用来绑定多个端口</code></pre><p><2>查看映射端口配置：docker port nostalgic_morse 5000</2></p><p><3> 新建网络：docker network create -d bridge my-net</3></p><pre><code>&gt; -d 参数指定 Docker 网络类型，有 bridge overlay</code></pre><p><4>连接容器：docker run -it –rm –name busybox1 –network my-net busybox sh （运行一个容器并连接到新建的 my-net 网络）</4></p><pre><code>docker run -it --rm --name busybox2 --network my-net busybox sh （再运行一个容器并加入到 my-net 网络）&gt; busybox1 与 busybox2 可相互ping通</code></pre><p>Example :</p><p>1.安装Ubuntu：docker pull ubuntu</p><p>2.run container : docker run -tid –name ubuntu -p 23:22 ubuntu：将新建的docker命名为ubuntu并映射到23端口</p><p>3.查看23号端口是否开启：netstat -apnl | grep 23（linux） /  netstat -AaLlnW ｜grep 23（mac）/  lsof -i:23 (mac)</p><p>4.进入container：docker exec -ti ubuntu /bin/bash  </p><p>5.修改root密码：passwd</p><p>6.更新vim：apt install -y vim （也许需要apt update）</p><p>7.安装openssh-server：  apt install -y openssh-server</p><p>8.修改配置，可使用root登录：vim /etc/ssh/sshd_config ，添加PermitRootLogin yes ；添加UsePAM no</p><p>9.启动ssh：service ssh start</p><p>10.重新进入docker container：ssh root@ip -p 23</p><hr><hr><h4 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h4><hr><h6 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="- 基本概念"></a>- 基本概念</h6><p>定义和运行多个 Docker 容器的应用，允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目</p><pre><code>&gt; 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。&gt; 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</code></pre><p>docker-compose [-f=<arg>…] [options] [COMMAND] [ARGS…]</arg></p><hr><hr><h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><hr><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="/09/docker/docker.png" alt></p><p><img src="/09/docker/virtualization.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker / docker-compose 相关概念及常用命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>没有知识的荒原</title>
    <link href="/2019/04/12/welcome/"/>
    <id>/2019/04/12/welcome/</id>
    <published>2019-04-12T07:52:25.000Z</published>
    <updated>2019-10-09T15:01:25.311Z</updated>
    
    <content type="html"><![CDATA[<p>真的<br><a id="more"></a><br>没有意思！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
