<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜻蜓队长前来觐见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-10-10T03:16:54.256Z</updated>
  <id>/</id>
  
  <author>
    <name>Jinnew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2019/10/10/linux/"/>
    <id>/2019/10/10/linux/</id>
    <published>2019-10-10T02:23:04.000Z</published>
    <updated>2019-10-10T03:16:54.256Z</updated>
    
    <content type="html"><![CDATA[<p>man 命令名    #查看命令的详细说明<br>命令名 -help   #查看命令的常用选项</p><a id="more"></a><p><strong>1 下载与安装</strong></p><p>下载：</p><pre><code>wget url #下载文件 （wget 命令常用于下载）curl www.baidu.com #请求指定网址并显示 （curl 命令可用于各种请求方式，常用于上传与请求）</code></pre><p>安装：解压缩 （如：<span style="color: rgb(0, 0, 0);">tar -xzvf soft.tar.gz），进入解压后的文件夹</span></p><pre><code>./configure（生成makefile文件）makemake install</code></pre><p><strong>2 文件命令</strong></p><p>创建文件：touch 文件名</p><p>删除文件：rm -rf 文件名  #r代表递归，f代表强制删除</p><p>查看文件：</p><p><img src="/2019/10/10/linux/file.png" alt></p><p>建立软连接：ln -s 源文件 目标文件</p><pre><code>#文件名都必须写绝对路径#删除了源文件，那么目标文件就会被标识为红色，但仍指向源文件；重新新建源文件，目标文件依然可用</code></pre><p>比较文件差异：diff 选项 文件一  文件二</p><p><strong>3 目录操作</strong></p><p><img src="/2019/10/10/linux/dir.png" alt></p><p><strong>4 文件和目录操作</strong></p><p><img src="/2019/10/10/linux/file-and-dir.png" alt></p><p>更改用户：sudo chown -R $USER /usr/local/lib/node_modules</p><p><strong>5 权限管理</strong></p><p><img src="/2019/10/10/linux/right.png" alt></p><p><strong>6 压缩解压</strong></p><p><img src="/2019/10/10/linux/compress.png" alt></p><p><strong>7 查找搜索</strong></p><p><img src="/2019/10/10/linux/find.png" alt></p><p><strong>8 SSH</strong></p><p>ssh [-p port] user@remote</p><pre><code>user 是在远程机器上的用户名，如果不指定的话默认为当前用户remote 是远程机器的地址，可以是IP/域名，或者是别名port 是SSH Server监听的端口，如果不指定，就为默认值22(使用exit退出当前用户的登录)</code></pre><p>设置ssh密钥：ssh-keygen</p><p>上传公钥到服务器：</p><pre><code>ssh-copy-id -p port user@remote（ssh-copy-id -p 22 deepin2@192.168.56.132）让远程服务器记住密钥，之后免密登陆</code></pre><p><strong>9 快捷键</strong></p><p><img src="/2019/10/10/linux/shortcut.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;man 命令名    #查看命令的详细说明&lt;br&gt;命令名 -help   #查看命令的常用选项&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用命令" scheme="/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>git常见命令</title>
    <link href="/2019/10/10/git/"/>
    <id>/2019/10/10/git/</id>
    <published>2019-10-09T17:57:55.000Z</published>
    <updated>2019-10-10T14:22:07.035Z</updated>
    
    <content type="html"><![CDATA[<p>git add [files]</p><a id="more"></a><p>git commit</p><p>git pull —rebase ( if conflicts happen, resolve merge conflicts )</p><p>git rebase —continue</p><p>git push</p><p>在任何时候，都可以用git rebase –abort参数来终止rebase的行动，并且分支会回到rebase开始前的状态。</p><pre><code>git pull = git fetch + git mergegit pull --rebase = git fetch + git rebase</code></pre><p><strong>1 切换分支</strong>： git checkout [branch name]</p><pre><code>git checkout -- a.txt   # 丢弃某个文件修改git checkout -- .       # 丢弃全部</code></pre><p>创建分支 git branch [branch name]</p><p>切换并生成分支 git checkout -b [branch name]</p><p><strong>2 合并分支</strong>：切换到主分支，使用 git merge / git rebase</p><p>假设目前存在两个分支master、bugfix<br><img src="/2019/10/10/git/two-branches.png" alt></p><p>使用git merge，合并两个修改会生成一个提交，master分支的HEAD会移动到该提交上。<br><img src="/2019/10/10/git/git-merge.png" alt></p><p>git rebase bugfix分支到master分支, bugfix分支的历史记录会添加在master分支的后面。<br><img src="/2019/10/10/git/git-rebase.png" alt></p><p><strong>3 添加远程库</strong>：git remote add origin [repo name]</p><pre><code>git push -u origin master= git push origin master ; git branch --set-upstream master origin/master</code></pre><blockquote><p> 使用-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来<br>–set-upstream：sets the default remote branch for the current local branch.</p></blockquote><p><strong>4 版本回退</strong>：假设C 和 D 是错误提交<br><img src="/2019/10/10/git/error-sumbit.png" alt></p><p><strong>git reset:</strong></p><ul><li><p>Use this to <strong>return</strong> the <em>entire</em> working tree to the last committed state. <em>This will discard commits in a private branch or throw away uncommitted changes!</em></p></li><li><p>Changes which commit a branch HEAD is currently pointing at. It alters the existing commit history.</p><blockquote><p>如果使用：git reset –hard a0fvf8；失去C和D的提交信息</p></blockquote></li></ul><p><img src="/2019/10/10/git/git-reset.png" alt></p><pre><code>git reset --soft xxx：只回退commit，如果你想再次提交直接git commit即可git reset --hard xxx：彻底回退版本，连本地文件都会被回退到上个版本的内容</code></pre><p><strong>git revert :</strong></p><ul><li><p><strong>Rollback changes</strong> you have committed.</p></li><li><p>Creates a <strong>new commit</strong> from a specified commit by inverting it. Hence, adds a new commit history to the project, but it does not modify the existing one.</p><blockquote><p>先 revert D，再 revert C<br>git revert 5lk4er; git revert 76sdeb<br>生成两个新有提交：D’ 和 C’,错误的提交 C 和 D 依然保留</p></blockquote></li></ul><p><img src="/2019/10/10/git/git-revert.png" alt></p><p>revert多个提交</p><pre><code>git revert OLDER_COMMIT^..NEWER_COMMIT （git revert B^..D -&gt; revert B,C,D）</code></pre><blockquote><p>如果不想三个revert生成三个新的commit，而是用一个commit完成，可以：<br>git revert -n OLDER_COMMIT^..NEWER_COMMIT<br>git commit -m “revert OLDER_COMMIT to NEWER_COMMIT”</p></blockquote><p>eg: 错误提交位于中间,直接使用 git reset 命令将 HEAD 指针重置到 A 提交显然是不行的，因为 C 提交是正确的，需要保留的。</p><p><img src="/2019/10/10/git/eg1.png" alt></p><p>推荐做法：先把 C 提交 及 B 提交全部回退，再使用 cherry-pick 命令将 C 提交重新再生成一个新的提交 C’</p><p><img src="/2019/10/10/git/eg2.png" alt></p><p><strong>5 cherry-pick：</strong></p><p><img src="/2019/10/10/git/cherry-pick.png" alt></p><p>只将C2合并到master，丢弃C3的修改</p><ul><li><p>用git log查看C2 commit的id</p></li><li><p>git checkout 到master分支下</p></li><li><p>git cherry-pick <c2_id></c2_id></p></li></ul><p>如果出现冲突，</p><ul><li><p>先解决冲突</p></li><li><p>git add 将解决了冲突的文件添加到暂存区</p></li><li><p>git cherry-pick –continue</p></li></ul><p><strong>6 git reflog：</strong></p><p>可以查看所有分支的所有操作记录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git add [files]&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用命令" scheme="/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>docker 基本概念与命令</title>
    <link href="/2019/10/09/docker/"/>
    <id>/2019/10/09/docker/</id>
    <published>2019-10-09T15:07:19.000Z</published>
    <updated>2019-10-10T06:24:58.761Z</updated>
    
    <content type="html"><![CDATA[<p>docker / docker-compose 相关概念及常用命令</p><a id="more"></a><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><hr><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="- 基本概念"></a>- <strong>基本概念</strong></h6><p>Docker是一种容器，操作系统级别的轻量级虚拟化，可以把环境一起打包扔给各服务器，随时随地都能运行。（保证运行环境一致）</p><p>Docker镜像（image）：相当于root文件系统，内核启动后为其提供用户空间支持。<br>除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker容器（container）：实质是进程，镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，image是container的静态定义（可类比 hello_world.py文件 和 对应的hello_world进程），容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>Docker Register：镜像构建完成后，如果需要在其它服务器上使用，那么就需要一个集中的存储、分发镜像的服务<br>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像<br>通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像</p><h6 id="常用命令"><a href="#常用命令" class="headerlink" title="- 常用命令"></a>- <strong>常用命令</strong></h6><p><strong>1. 镜像</strong></p><p>&lt;1&gt; 获取镜像：docker pull [选项] [Docker Registry 地址 [:端口号] /] 仓库名 [:标签]</p><pre><code>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。仓库名： &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</code></pre><p>&lt;2&gt;列出镜像：docker image ls</p><pre><code>查看中间层镜像：docker image ls -a列出部分镜像：       根据仓库名列出镜像：docker image ls ubuntu       指定仓库名和标签：docker image ls ubuntu:18.04       过滤器参数（--filter）：docker image ls -f since=mongo:3.2 （mongo:3.2之后的镜像）       以特定格式显示（-q/--format）：docker image ls --format &quot;{{.ID}} : {{.Repository}}&quot;</code></pre><p>&lt;3&gt;删除虚悬镜像：docker image prune</p><p>&lt;4&gt;删除本地镜像：docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p><pre><code>配合 ls使用：docker image rm $(docker image ls -q redis)    （删除所有仓库名为redis的镜像）docker image rm $(docker image ls -q -f before=mongo:3.2)。（删除所有在mongo:3.2之前的镜像）</code></pre><p>&lt;5&gt;运行容器时修改了文件，保存成最终镜像：<br>docker commit [选项]&lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]]   （慎用，黑箱镜像）</p><pre><code>eg：docker commit --author &quot;Tao Wang &lt;[twang2218@gmail.com](mailto:twang2218@gmail.com)&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</code></pre><p>&lt;6&gt;定制镜像：Dockerfile</p><pre><code>一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 From指定基础镜像，Run 执行命令 构建镜像：docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p><strong>2. 容器</strong></p><p>&lt;1&gt;新建并启动：docker run</p><p>&lt;2&gt;启动已终止容器：docker container start [container ID or NAMES]</p><p>&lt;3&gt;后台运行(-d): </p><pre><code>docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done”</code></pre><p>&lt;4&gt;查看容器信息：docker container ls</p><p>&lt;5&gt; 获取容器的输出信息：docker container logs [container ID or NAMES]</p><p>&lt;6&gt;终止容器：docker container stop [container ID or NAMES]</p><p>&lt;7&gt;重启运行中的容器：docker container restart [container ID or NAMES]</p><p>&lt;8&gt;进入容器：docker attach [container ID or NAMES]  (从 stdin 中 exit，会导致容器停止)</p><pre><code>docker exec -it [container ID or NAMES] bash (从 stdin 中 exit，不会导致容器停止，推荐)&gt; -I: interactive, keep stdin -iopen&gt; -t: 分配伪终端</code></pre><p>&lt;9&gt;导出容器：docker export [container ID] &gt; ubuntu.tar</p><p>&lt;10&gt;导入容器：cat ubuntu.tar | docker import - test/ubuntu:v1.0</p><p>&lt;11&gt;删除容器：docker container rm [container ID or NAMES] （运行中的容器可使用-f参数）</p><p>&lt;12&gt;清理所有处于终止状态的容器：docker container prune</p><p><strong>3. 仓库</strong></p><p>&lt;1&gt;查找官方仓库中的镜像：docker search</p><p>&lt;2&gt;推送镜像到 Docker Hub：docker push</p><p><strong>4. 数据管理</strong></p><p>&lt;1&gt;数据卷</p><pre><code>创建：docker volume create my-vol查看：docker volume ls启动一个挂载数据卷的容器（--mount）：docker run -d -P \                                 --name web \                                 --mount source=my-vol,target=/webapp \                                 training/webapp \                                 python [app.py](http://app.py/)（创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。） 查看数据卷的具体信息：docker inspect web 删除数据卷：docker volume rm my-vol</code></pre><p><strong>5. 使用网络</strong></p><p>&lt;1&gt;外部访问容器（-P/-p）：docker run -d -P training/webapp python <a href="http://app.py/" target="_blank" rel="noopener">app.py</a><br>                       (使用-P标记时，Docker 会随机映射一个49000~49900的端口到内部容器开放的网络端口)</p><pre><code>docker run -d -p 5000:5000 training/webapp python [app.py](http://app.py/) (本地的5000 端口映射到容器的5000 端口)127.0.0.1:5000:5000  指定地址到指定端口 / 127.0.0.1::5000 指定地址的任意端口 / 127.0.0.1:5000:5000/udp 指定 udp 端口-p可以多次使用来绑定多个端口</code></pre><p>&lt;2&gt;查看映射端口配置：docker port nostalgic_morse 5000</p><p>&lt;3&gt; 新建网络：docker network create -d bridge my-net</p><pre><code>&gt; -d 参数指定 Docker 网络类型，有 bridge、overlay</code></pre><p>&lt;4&gt;连接容器：</p><pre><code>docker run -it --rm --name busybox1 --network my-net busybox sh （运行一个容器并连接到新建的 my-net 网络）docker run -it --rm --name busybox2 --network my-net busybox sh （再运行一个容器并加入到 my-net 网络）&gt; busybox1 与 busybox2 可相互ping通</code></pre><p>Example :</p><p>1.安装Ubuntu：docker pull ubuntu</p><p>2.run container : docker run -tid –name ubuntu -p 23:22 ubuntu：将新建的docker命名为ubuntu并映射到23端口</p><p>3.查看23号端口是否开启：netstat -apnl | grep 23（linux） /  netstat -AaLlnW ｜grep 23（mac）/  lsof -i:23 (mac)</p><p>4.进入container：docker exec -ti ubuntu /bin/bash  </p><p>5.修改root密码：passwd</p><p>6.更新vim：apt install -y vim （也许需要apt update）</p><p>7.安装openssh-server：  apt install -y openssh-server</p><p>8.修改配置，可使用root登录：vim /etc/ssh/sshd_config ，添加PermitRootLogin yes ；添加UsePAM no</p><p>9.启动ssh：service ssh start</p><p>10.重新进入docker container：ssh root@ip -p 23</p><hr><hr><h4 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h4><hr><h6 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="- 基本概念"></a>- 基本概念</h6><p>定义和运行多个 Docker 容器的应用，允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目</p><pre><code>&gt; 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。&gt; 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</code></pre><p>docker-compose [-f=<arg>…] [options] [COMMAND] [ARGS…]</arg></p><hr><hr><h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><hr><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="/2019/10/09/docker/docker.png" alt></p><p><img src="/2019/10/09/docker/virtualization.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker / docker-compose 相关概念及常用命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用命令" scheme="/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>没有知识的荒原</title>
    <link href="/2019/04/12/welcome/"/>
    <id>/2019/04/12/welcome/</id>
    <published>2019-04-12T07:52:25.000Z</published>
    <updated>2019-10-09T15:01:25.311Z</updated>
    
    <content type="html"><![CDATA[<p>真的</p><a id="more"></a><p>没有意思！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
